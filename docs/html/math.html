<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mackey: From Math to Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mackey
   &#160;<span id="projectnumber">V3</span>
   </div>
   <div id="projectbrief">A C++ library for computing RO(G) homology</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">From Math to Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Briefly">Briefly</a></li>
<li class="level1"><a href="#imd">In more detail</a><ul><li class="level2"><a href="#add">The additive structure</a></li>
<li class="level2"><a href="#mack">&quot;Universal&quot; Additive Notation</a></li>
<li class="level2"><a href="#iso">Isomorphic Mackey Functors</a></li>
<li class="level2"><a href="#mult">The multiplicative structure</a></li>
<li class="level2"><a href="#factor">Factorization</a></li>
<li class="level2"><a href="#Mass">Massey Products</a></li>
</ul>
</li>
<li class="level1"><a href="#caveat">A caveat</a><ul><li class="level2"><a href="#cyclic">Cyclic Generators</a></li>
<li class="level2"><a href="#noncycl">Non cyclic generators</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="Briefly"></a>
Briefly</h1>
<p>There are three fundamental ideas the code is based on:</p>
<ul>
<li>The homology of chain complexes of free modules can be algorithmically computed by turning the differentials into matrices and then diagonalizing them (Smith Normal Form).</li>
<li>Free <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functors (namely, free modules over a constant <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor) are determined by their bottom level. The higher levels are obtained by taking fixed points under the Weyl group action, and this can be done algorithmically on our matrices by writing them with respect to equivariant bases (an equivariant basis is an ordered basis in which elements in the same orbit are written consecutively).</li>
<li>Box products of <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functors are tensor products on the bottom level. This is not true for the higher levels, however using the bulletpoint above, higher levels are obtained by transferring. This is how box products of chain complexes of free <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functors are computed.</li>
</ul>
<p>These three ideas dictate our approach: We start with the standard chains (the chains for spheres \(S^V\) where \(V\) is an actual, as opposed to virtual, real \(G\)-rep) on the bottom level, and box them to get the bottom level chains for any \(S^V\) where \(V\) is any virtual representation. By transferring we get the higher level chains, from which the homology groups are computed level-wise. The generators for these homology groups are defined on the chain level, where we can compute the transfer/restriction/Weyl group action on them. This means that we can compute the transfer/restriction/Weyl group action maps on homology, thus determining the <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor structure of \(H_*(S^V)\).</p>
<p>By converting all our differentials to matrices, using equivariant bases throughout, we can reduce our computations to pure linear algebra (over the integers, or other coefficients).</p>
<h1><a class="anchor" id="imd"></a>
In more detail</h1>
<p>Here's how the code works in more detail (for simplicity we specialize to the \(G=C_4\) case, although everything works equally well with general prime powers):</p>
<h2><a class="anchor" id="add"></a>
The additive structure</h2>
<ul>
<li>The inputs are the bottom levels of the standard chains, namely the chains of the spheres \(S^{n\sigma+m\lambda}\) for \(n,m\ge 0\). It actually suffices to only use \(S^{\sigma},S^{\lambda}\) as inputs and then obtain every other sphere as iterated smash products of these, but this would result in taking arbitrarily many box products and incur a huge performance penalty. Instead, if we use the spheres \(S^{n\sigma+m\lambda}\) for \(n,m\ge 0\) as inputs, we only have to take double box products at worst, and that's only for part of the multiplicative structure (see below).</li>
<li>The data of a chain complex are the ranks of each \(C_*\) and the differentials \(d:C_*\to C_{*-1}\). The differentials are stored as matrices and the ranks are stored as integer arrays. Integer arrays and not integers are used in order to record the equivariant information: For example \(\mathbb Z[C_4]\) is different from \(\mathbb Z[C_2]\oplus \mathbb Z[C_2]\) even though they both have rank \(4=2+2\) over \(\mathbb Z\). With our conventions, \(\mathbb Z[C_2]\oplus \mathbb Z[C_2]\) has rank \([2,2]\) while \(\mathbb Z[C_4]\) has rank \(4\).</li>
<li>Starting with the bottom level chains, we transfer both ranks and differentials to get the higher level chains. While transferring ranks is straightforward, transferring differentials is quite a bit more complicated and requires to have already transferred the ranks of the domain and range of the differentials.</li>
<li>Using the classical homology algorithm we compute the groups of the <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor at every level. We also compute their generators (as elements in the chain complex).</li>
<li>We transfer/restrict and compute the Weyl group action on these generators. This concludes the <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor computation for the \(S^{n\sigma+m\lambda}\), \(n,m\) having the same sign (if \(n,m&lt;0\) we take the dual chain complex, which has the effect of transposing all matrices for the differentials).</li>
<li>To obtain the chains of any representation sphere, we box the standard chains. Boxing is more complicated compared to just taking tensor products, as we have to use equivariant bases throughout to transfer properly. However the most convenient bases for tensoring (the lexicographical ones) are not equivariant, and in the end we have to change bases through permutation matrices.</li>
<li>We then compute the homology of the boxed chains as above.</li>
</ul>
<h2><a class="anchor" id="mack"></a>
"Universal" Additive Notation</h2>
<p>While a <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor is determined by the groups, transfers, restrictions and Weyl group actions, it is desirable to have a "universal" notation to concisely describe any <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor. Here's the notation we use:</p>
<ul>
<li>First assume all levels are cyclic groups, and that in each transfer-restriction pair, one map is multiplication by 2 and the other map is multiplication by 1. The notation \(a_1...a_n \sharp b_1...b_m\) expresses a <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor whose levels are \(\mathbb Z/a_i\) if \(a_i\neq 1\) and \(\mathbb Z\) if \(a_i=1\), with the bottom level corresponding to \(a_1\) and the top to \(a_n\). Furthermore, the transfers between levels \(b_i\to b_{i+1}\) are multiplication by 1 (the rest of the transfers are multiplication by \(2\) by assumption). The restrictions are computed by assumption, while the Weyl group actions are determined by the double coset formula.</li>
<li>\(a_1...a_n \sharp b_1...b_m + c_1...c_n\sharp d_1...d_l\) corresponds to the sum of <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functors of the above form. This generalizes to sums of more than 2 <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functors.</li>
<li>For \(C_4\), every <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor can be written as above. For \(C_8\) and \(\mathbb Z\) coefficients there are three exceptional <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functors that can't be expressed in our "universal" notation.</li>
</ul>
<h2><a class="anchor" id="iso"></a>
Isomorphic Mackey Functors</h2>
<p>Isomorphic <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functors can have different "universal" notations. To find if two different notations correspond to isomorphic <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functors (and are thus equivalent), it suffices to compute all different notations in each isomorphism class.</p>
<ul>
<li>Given a <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor \(M\) we compute its isomorphism class as follows: First, for each level \(M(G/H)\) we find all its (group) automorphisms \(Aut(M(G/H))\). Choosing one automorphism for each \(H\) gives a <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor automorphism of \(M\) (as long as the level-wise choices commute with restrictions/transfers/Weyl group actions). In the end we get \(Aut(M)\) and applying the automorphisms on \(M\) returns the isomorphism class.</li>
<li>For finitely generated (abelian) groups with only one \(\mathbb Z\) factor, there are only finitely many automorphisms and we can easily classify them all.</li>
<li>If there is more than one \(\mathbb Z\) factor, there are infinitely many automorphisms, so the user must provide those that the program should use for the identification.</li>
</ul>
<h2><a class="anchor" id="mult"></a>
The multiplicative structure</h2>
<p>Once we have the additive structure (the universal notation isn't needed for this), we can compute the product of two additive generators \(a,b\) through the following process.</p>
<ul>
<li>First we restrict the generators \(a,b\) to the bottom level to get \(Res(a),Res(b)\) as elements of two chain complexes.</li>
<li>We then compute \(Res(a)Res(b)\) as an element of the box product of the two chain complexes on the bottom level.</li>
<li>\(Res(a)Res(b)\) is the restriction of a unique element, \(ab\) (since our chains are free <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functors). By inverting the restriction we can get \(ab\) as an element of the box product.</li>
<li>We finally write \(ab\) in terms of the generators of the homology of the box product.</li>
</ul>
<p>Once we know how to multiply any two additive generators, we have in effect determined the multiplicative structure (see <a class="el" href="math.html#caveat">A caveat</a> for a catch).</p>
<h2><a class="anchor" id="factor"></a>
Factorization</h2>
<p>Even if we can multiply any two generators, that doesn't mean we can automatically write any element as a product of our preferred generators. For example, it's easy to see that the generator of \(H_{-2}S^{-2\sigma}\) is \(2/u_{2\sigma}\) (multiply with \(u_{2\sigma}\) and get result \(1\)). On the other hand, coming up with the expression \(2/u_{2\sigma}\) of the generator is a lot more complicated. The factorization process performs this automatically:</p>
<ul>
<li>First we form a multiplication table, where all generators (in a range) are multiplied with the "basic irreducibles". These basic irreducibles can be the Euler and orientation classes.</li>
<li>We then get a directed colored graph by drawing \(a\to ab\) for \(b\) a basic irreducible; we color these edges red. If multiplication by \(b\) is an isomorphism i.e. \(a=(ab)/b\) then we also draw \(ab\to a\); we color such edges blue.</li>
<li>Since the product \(ab\) may not be a generator, but rather a multiple of it, we need to allow nonzero multiples of generators as distinct nodes.</li>
<li>To obtain a factorization, we simply need to connect 1 with any node in the graph. For the most efficient factorizations, we want to minimize the number of times we alternate between blue and red edges in each path (eg we prefer \(b^2\) to \(a(b/a)b\)). This is done by a modified Dikjstra algorithm.</li>
<li>For the generators not connected to 1 (eg \(s\)) we need to perform the same process using different sources for our graph (eg using \(s\) as the source for all paths).</li>
</ul>
<h2><a class="anchor" id="Mass"></a>
Massey Products</h2>
<p>The chains-based approach we use means that Massey products can be computed from definition. The only extra thing we need is the following:</p>
<ul>
<li>Given an element \(x\) that vanishes in homology we can find a \(y\) that bounds it: \(dy=x\). This is part of our homology algorithm.</li>
</ul>
<p>So Massey products work like this:</p>
<ul>
<li>Suppose we have \(ab=bc=0\) in homology. We lift \(a,b,c\) to chains \(C,D,E\) and explicitly compute \(ab, bc\) in \(C\otimes D\) and \(D\otimes E\) respectively, as in <a class="el" href="math.html#mult">The multiplicative structure</a>.</li>
<li>After that we find \(ds=ab, dt=bc\) and form \(sc\) and \(at\) in the box products \((C\otimes D) \otimes E\) and \(C\otimes (D\otimes E)\) respectively.</li>
<li>These box products are isomorphic up to a permutation that we can explicitly compute. Thus we can write \(sc\) and \(at\) as elements of the same chain complex in the same basis.</li>
<li>Finally we form \(sc+(-1)^{|a|+|b|+1}at\) and compute its image in homology.</li>
</ul>
<h1><a class="anchor" id="caveat"></a>
A caveat</h1>
<h2><a class="anchor" id="cyclic"></a>
Cyclic Generators</h2>
<ul>
<li>The way we prove that a transfer map is (say) multiplication by \(2\), is by computing the generators at the domain and target, computing the transfer of the domain generator and comparing with the target. Of course, there are usually multiple choices of generators, but up to isomorphism we get the same <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functor.</li>
<li>There is a catch however that appears when computing the multiplicative structure: If we prove that \(ab\) and \(cd\) are both generators of the same cyclic group, then we can't conclude that they are equal. Eg if the group is \(\mathbb Z/4\) or \(\mathbb Z\) then they may differ by a sign. Still, since we are interested in generating the \(RO(G)\) homology, as opposed to finding exact relations, we don't have to distinguish between cyclic generators so we don't need to worry about this detail.</li>
<li>If we are interested in exact relations, then are ways to resolve the ambiguity as we explain in the following subsection.</li>
</ul>
<h2><a class="anchor" id="noncycl"></a>
Non cyclic generators</h2>
<ul>
<li>There is a situtation where the caveat above cannot be worked-around and that's when we have non cyclic groups. A typical example: If we have \(\mathbb Z\oplus \mathbb Z/2\) with generators \(x,y\) respectively then we can't distinguish \(x\) from \(x+y\) as there is an automorphism of \(\mathbb Z\oplus \mathbb Z/2\) exchanging them. In that case the difference between \(ab\) and \(cd\) generating the same group can be greater than just an integer coprime to the group's order (or a sign).</li>
<li>For another example, when computing the \(RO(C_4)\) homology in \(\mathbb F_2\) coefficients the group \(\mathbb F_2\oplus \mathbb F_2\) tends to appear frequently; unfortunately its three generators cannot be distingusihed.</li>
<li>One way out of this is to break down our box products further until they can be directly compared. Eg we can compare the chains for \(S^{2\sigma+\lambda}\wedge S^{-\lambda}\) with those for \(S^{\sigma+\lambda}\wedge S^{\sigma -\lambda}\) by using the chains for \(S^{\sigma}\wedge S^{\sigma}\wedge S^{\lambda}\wedge S^{-\lambda}\) as an intermediate. This is difficult to program generally and comes at a very high performance cost as we need more iterated box products.</li>
<li>Another way is to use the fact that these noncyclic homology groups result from extensions of <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent.">Mackey</a> functors, not just group extensions. So for example in \(\mathbb Z\oplus \mathbb Z/2\) we can distinguish \(x\) from \(x+y\) using that \(x\) is a transfer. This doesn't always work: We can have a \(\mathbb F_2\oplus \mathbb F_2\) generated by \(x,y\) with \(x\) having restriction \(0\) while \(y\) having restriction \(1\) and no generator being a transfer; in this case we cannot distinguish between \(y\) and \(x+y\).</li>
<li>There is one final trick we can use to resolve this ambiguity as it appears the Factorization algorithm: Assume we have \(ab\) in \(\mathbb F_2\{x,y\}\) and we know \(ab=x\) or \(ab=x+y\). For each element \(z\) we can compute the products \(xz\) and \((x+y)z\). If for some \(z\) these products are different and can be distinguished, say \(c,d\), then we can form \(abz\) internally (triple box product) and compare the answer to \(c\) and \(d\); if \(abz=c\) then \(ab=x\).</li>
</ul>
<p>In practice, for \(\mathbb Z\) coefficients and \(G=C_4\) we can choose to ignore the products we can't immediately identify and make no determination as to the equality of \(ab\) and \(cd\) if they live in non cyclic groups. This gives us less data to work with, but it turns out to be sufficient in writing the factorization of any element.</p>
<p>That doesn't work for \(\mathbb F_2\) coefficients and \(G=C_4\), or \(\mathbb Z\) coefficients and \(G=C_8\), as there are simply too many instances of noncyclic groups. Instead we need to use all the bulletpoints above to identify our generators and factorize every element.</p>
<p>If we are only interested in the connectivity of the multiplication graph (whether or not everything being generated by Euler+orientation classes) then we don't need to make all identifications: If \(ab\) is \(x\) or \(x+y\) and \(x,y\) are connected to the source of the graph and multiplication by \(b\) is an injection on \(a\), then it doesn't matter if the answer is \(x\) or \(x+y\): in both cases, \(a\) is also connected to the source. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
