\mainpage General Information
\tableofcontents
 \section intro Introduction
This is a C++ header only library for computing \f$RO(G)\f$ (co)homology of \f$G\f$-spaces. You can find the GitHub repository <a href="https://github.com/NickG-Math/Mackey">here</a>.

For a quick demonstration in the case of \f$G=C_4\f$, use one of the available binaries  <a href="https://github.com/NickG-Math/Mackey/releases">here</a>.

\section req Requirements
 * A C++17 compiler such as Clang, GCC or MSVC.
 * <a href=" http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>, a header-only matrix math-library.
 * Optionally, <a href=" https://uscilab.github.io/cereal/">cereal</a>, a header-only serialization library.

\section install Installation

* To install simply clone/download the <a href="https://github.com/NickG-Math/Mackey">repository</a> and include the folder called "source" in your path. You will also need to include %Eigen and optionally cereal.

* See the page \ref tuto for a tutorial on using the library.

* The latest version of the code has been tested with Eigen 3.3.9 and the latest stable versions of Clang, GCC (Linux) and MSVC (Windows). 

* You'll need to enable C++17 in your compiler; with Clang and GCC this is done by the option ```-std=c++17```.

\section doc Documentation

This documentation is organized in pages as follows:
 
* The pages \ref math and \ref algo, explain how the program works, starting from the math and moving to slightly more technical territory regarding the actual implementation.

* The page \ref tuto is a tutorial on using the library.

* The page \ref ext is about extending the library and future goals.

* The pages <a href="namespaces.html">Namespaces</a>, <a href="annotated.html">Classes</a>  and <a href="files.html">Files</a> are automatically generated by doxygen from the source code (and comments in the source code). These offer a much more in-depth look into all classes and functions of this project. Note that only public and protected members and named namespaces are documented.

* I recommend starting with the <a href="namespaces.html">related pages</a> before moving to the automatically generated ones. If you just want to use this library for computations, you only really have to go over the \ref tuto section.


\page math From Math to Code
\tableofcontents

\section nut In a nutshell

The aim of this library is to solve the following problem:\n
Given inputs:
* \f$G\f$ = the ambient group eg \f$C_4\f$.
* \f$R\f$ = the base PID with trivial \f$G\f$-action eg \f$\mathbf Z\f$ or \f$\mathbf Z/p\f$.
* \f$X\f$ = a \f$G\f$-CW space eg a point or \f$B_{C_4}\Sigma_2\f$.
* The bottom level chain complexes \f$C_*^e(S^V)\f$ corresponding to finite \f$G\f$-CW 
decompositions of \f$S^V\f$ where \f$V\f$ ranges over all real \em non-virtual \f$G\f$-reps.
* The bottom level chain complex \f$C_*^e(X)\f$ corresponding to a finite \f$G\f$-CW 
decomposition of \f$X\f$.

produce output:

* The \f$RO(G)\f$ graded homology \f$H_{\star}(X)\f$ and cohomology \f$H^{\star}(X)\f$ as Mackey functor
modules over the Green functor \f$H_{\star}\f$.

The library can also compute Massey products \f$\langle a,b,c\rangle\f$ for \f$a,b,c\in H_{\star}\f$ with \f$ab=bc=0\f$.


@note 
* \f$X=B_{C_4}\Sigma_2\f$ is an infinite dimensional CW-complex so we replace it by the finite skeleta \f$B_{C_4}\Sigma_2(j)\f$.
* Computing the multiplicative structure (including Massey products) involves comparing generators from homotopy equivalent chain complexes. This is not always possible without an explicit chain homotopy (see \ref caveat).


\section br Briefly

What enables this library to work is that free Mackey functors are determined on their bottom level by transferring:

* By a "free Mackey functor" we mean a finite sum of the form:
\f[\oplus_H\underline{R[G/H]}\f]
where \f$H\f$ ranges over (conjugacy classes of) subgroups of \f$G\f$ (we allow repetitions).
* For a free Mackey functor \f$M\f$ we have \f$M(G/H)=M(G/e)^H\f$.

An application of this: box products of free Mackey functors are tensor products on the bottom level. This is not true for the higher levels, however we can obtain those by transferring. The same applies to duals.

Our approach that starts with \f$C_*^e(X), C_*^e(S^V)\f$ and computes \f$H_{\star}(X)\f$ can be summarized in the following diagram (in the case of \f$G=C_4\f$):

\n
\n

\image html diagram2.svg

\n
\n

@note Cohomology can be computed in the same way by first dualizing \f$C_*^e(X)\f$ to get \f$C^*_e(X)\f$. So in what follows we will only discuss the homology case.

To fully computerize this approach we make the following modifications:

* We replace all chain complex differentials with matrices. 

* Tensor/dual/transfer/homology all correspond to operations on matrices. For example homology is computed via the Smith Normal Form algorithm.

* The generators of each level of \f$H_{\star}(X)\f$ are reductions of explicit elements on \f$C_{\star}(X)\f$. This means that we can compute the effect of transfer/restriction/Weyl group action on them (by performing the computation on \f$C_{\star}(X)\f$), giving us the Mackey functor structure of \f$H_{\star}(X)\f$. 

We multiply the additive generators of \f$H_{\star}\f$ by performing the tensor/cross product on the chain level. This involves restricting and then inverting restrictions (which is possible since we have free Mackey functors). Diagrammatically:


\n
\n

\image html diagram3.svg

\n
\n


We similarly compute Massey products in \f$H_{\star}\f$ and the module structure of \f$H_{\star}(X)\f$ over \f$H_{\star}\f$.


\section mean Obtaining a useful output

Let us take \f$G=C_{p^n}\f$ and \f$R=\mathbf Z\f$.

\subsection mack "Universal" Mackey functor notation

While a Mackey functor is determined by the level-wise groups, transfers, restrictions and Weyl group actions, it is desirable to have a 
"universal" notation to concisely describe any Mackey functor. 

* The notation \f[a_0...a_n \sharp b_0...b_m\f] describes the Mackey functor \f$M\f$:
\f[M(C_{p^n}/C_{p^i})=\begin{cases}\mathbf Z/a_i&\text{ if }a_i\neq 1\\
\mathbf Z&\text{ if }a_i= 1\end{cases}
\\
Tr_{{p^i}}^{{p^{i+1}}}(x)=\begin{cases}x&\text{ if }i=b_j\text{ for some }j\\
2x&\text{ else }\end{cases}\\
Res_{{p^i}}^{{p^{i+1}}}(x)=\begin{cases}2x&\text{ if }i=b_j\text{ for some }j\\x&\text{ else }\end{cases}\f]
Here we assume \f$0\leq b_0<\cdots<b_m<n\f$. The Weyl group actions are determined by the double coset formula.

* More generally we extend the notation linearly to define arbitrary finite sums:
\f[a_0...a_n \sharp b_0...b_m + \cdots + c_0...c_n\sharp d_0...d_l\f] 

* For \f$G=C_4\f$, every Mackey functor can be written in this notation. For \f$G=C_8\f$ and \f$\mathbf Z\f$ coefficients there are three exceptional Mackey functors that can't be expressed in our "universal" notation.

\subsection iso Isomorphic Mackey functors

Isomorphic Mackey functors can have different "universal" notations. 
To find if two different notations correspond to isomorphic Mackey functors (and are thus equivalent), it suffices to compute all different notations in each isomorphism class.

Given a Mackey functor \f$M\f$ we compute its isomorphism class as follows:

*  For each level \f$M(G/H)\f$ we find all automorphisms \f$Aut(M(G/H))\f$.

* Choosing one automorphism for each \f$H\f$ gives a Mackey functor automorphism of \f$M\f$ (as long as the level-wise choices commute with restrictions/transfers/Weyl group actions). This gives \f$Aut(M)\f$.

* For finitely generated (abelian) groups with only one \f$\mathbf Z\f$ factor, there are only finitely many automorphisms and
we can easily classify them all.

@todo Make identification work even if there is more than one \f$\mathbf Z\f$ factor (so we get infinitely many automorphisms)


\subsection factor Factorization

Starting with a small group of generators, the factorization process tries to write every other generator in terms of them. \n
It goes as follows:

* First we form a multiplication table, where all generators (in a range) are multiplied with the "basic irreducibles". These basic irreducibles can be the Euler and orientation classes.

* We then get a directed colored graph by drawing \f$a\color{red}{\to} ab\f$ for \f$b\f$ a basic irreducible.

* If multiplication by \f$b\f$ is an isomorphism i.e. \f$a=(ab)/b\f$ then we also draw \f$ab\color{blue}{\to} a\f$

* Since the product \f$ab\f$ may not be a generator, but rather a multiple of it, we need to allow nonzero multiples of generators as distinct nodes.

* To obtain a factorization, we simply need to connect 1 with any node in the graph. 

* For the most efficient factorizations, we want to minimize the number of times we alternate between blue and red edges in each path. 
For example consider: \f[\frac{ab}{cd}\text{ vs } \frac{a \frac{b}{c}}{d}\f] 
We also want to minimize the total length of the paths. This is done by a modified Dijkstra algorithm.

* For the generators not connected to 1 (eg \f$s\f$) we need to perform the same process using different sources for our graph (eg using \f$s\f$ as the source for all paths).


\section caveat A caveat
\subsection cyclic Cyclic Generators

* The way we prove that a transfer map is (say) multiplication by \f$2\f$, is by computing the generators at the domain and target, computing the transfer of the domain generator and comparing with the target. 
Of course, there are usually multiple choices of generators, but up to isomorphism we get the same Mackey functor. 

* There is a catch however that appears when computing the multiplicative structure: If we prove that \f$ab\f$ and \f$cd\f$ are both generators of the same cyclic group, then we can't conclude that they are equal. 
Eg if the group is \f$\mathbf Z/4\f$ or \f$\mathbf Z\f$ then they may differ by a sign. 

* Since we are interested in generating the \f$RO(G)\f$ homology, as opposed to finding exact relations, we don't have to distinguish between cyclic generators so we don't need to worry about this detail.

* If we are interested in exact relations, then are ways to resolve the ambiguity as we explain in the following subsection.


\subsection noncyclic Non cyclic generators

* There is a situation where the caveat above cannot be worked-around and that's when we have non cyclic groups. \n
A typical example: 
\f[\mathbf Z\{x,y\}/2y=\mathbf Z\oplus \mathbf Z/2= \mathbf Z\{x+y,y\}/2y\f] 
and we can't distinguish \f$x\f$ from \f$x+y\f$ as there is an automorphism of \f$\mathbf Z\oplus \mathbf Z/2\f$ exchanging them. 

* Another example: Over \f$\mathbf F_2\f$ coefficients we can't distinguish the three generators of 

\f[\mathbf F_2\oplus \mathbf F_2\f]

* One way out of this is to break down our box products further until they can be directly compared. For example: 
\f[S^{2\sigma+\lambda}\wedge S^{-\lambda}=S^{\sigma}\wedge S^{\sigma}\wedge S^{\lambda}\wedge S^{-\lambda}S^{\sigma+\lambda}\wedge S^{\sigma -\lambda}\f] 
This is difficult to program generally and comes at a very high performance cost as we need more iterated box products.

* Another way is to use the fact that we actually have extensions of Mackey functors, not just group extensions. 
So for example if we have
\f[Tr:\mathbf Z\to \mathbf Z\{x,y\}/2y\\
Tr(1)=x\f] 
then we can distinguish \f$x\f$ from \f$x+y\f$ as only the former is a transfer. 

* This doesn't always work: We can have 
 \f[Res: \mathbf F_2\{x,y\}\to \mathbf F_2\\
 Res(x)=0\text{ , }Res(y)=1\\
 Tr:\mathbf F_2\to \mathbf F_2\{x,y\}\\
 Tr(1)=0\f]
 in which case we cannot distinguish between \f$y\f$ and \f$x+y\f$.

* There is one final trick that can help in the case above: If for some element \f$z\f$ we can distinguish \f$xz\f$ and \f$(x+y)z\f$ then this also distinguishes \f$x,x+y\f$.

* In practice, for \f$\mathbf Z\f$ coefficients and \f$G=C_4\f$ we can choose to ignore these problems and not draw any edges if we can't distinguish generators; this gives us less data to work with, but it turns out to be sufficient in writing the factorization of any element. 

* That doesn't work for \f$\mathbf F_2\f$ coefficients and \f$G=C_4\f$, or \f$\mathbf Z\f$ coefficients and \f$G=C_8\f$, as there are simply too many instances of noncyclic groups. Instead we need to use all the tricks above to identify our generators and factorize every element.

* If we are only interested in the connectivity of the multiplication graph (whether or not everything is generated by Euler+orientation classes) then we don't need to make all identifications as connecting \f$a\to x\f$ or \f$a\to x+y\f$ gives graphs with the same number of components.


@todo Implement Frobenius relations: The multiplicative structure is computed levelwise, but this could be done more effectively using the Frobenius relations 
\f[Tr(Res(x)y)=xTr(y)\f]

\page tuto Tutorial
\tableofcontents

The code examples here can be compiled from the .cpp file in the <a href="https://github.com/NickG-Math/Mackey/tree/master/demo">demo</a> folder.

\section incl Includes

Many parts of the library can be individually included. To keep things simple, we provide a single header file \ref Mackey.hpp that includes the entire library (and %Eigen)

@attention If you are using MSVC, including %Eigen will give compilation errors unless you define the following macro: 
\code #define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS \endcode
Make sure to define the macro \em before including \ref Mackey.hpp

@note To enable multithreading via openMP define the macro ```MACKEY_USE_OPENMP``` before including \ref Mackey.hpp and enable openMP in your compiler (on Clang and GCC this is done by
the flag ```-fopenmp```)

With that in mind, we start with:

      #include "Mackey.hpp"

\section name Namespaces

Everything in this library is under the namespace \ref mackey. For the following code examples we use:

      using namespace mackey;

\section temp Template parameters

The three template parameters that need to be set are the ambient group \f$G\f$, the coefficient ring \f$R\f$ and the \f$G\f$-space \f$X\f$. 
For these examples let us use \f$X=*\f$ which supports all of the library's features.

From the get-go the library provides support for:

* groups \f$G=C_{2^n}\f$ via the class \ref mackey::C2Power "C2Power"
* fields \f$\mathbf Z/p\f$ via the class \ref mackey::Z_mod "Z_mod"

@note The ring \f$\mathbf Z\f$ corresponds to the usual signed integer types eg \c int64_t so there's no need to define a wrapper around it (64bit accuracy is more than enough for these computations, and you can use an overflow sanitizer to protect against it).

For example ```C2Power<5,Z_mod<3>>``` is the type corresponding to group \f$C_{2^5}\f$ and coefficients \f$\mathbf Z/3\f$.\n
Another example: ```C2Power<1,int64_t>``` corresponds to group \f$C_2\f$ and coefficients \f$\mathbf Z\f$ with 64bit range.

@note We provide convenient typedefs for \f$C_2,C_4,C_8,C_{16}\f$ via the classes \ref mackey::C2 "C2", \ref mackey::C4 "C4", \ref mackey::C8 "C8", \ref mackey::C16 "C16". 

@note We provide a convenient typedef for \f$\mathbf Z/2\f$ via \ref mackey::Z2 "Z2".

For the following examples we shall use the configuration:

      typedef C4<int64_t> group_t;

which means \f$\mathbf Z\f$ coefficients and group \f$C_4\f$.

\section next Code Examples

\subsection add The additive structure

The class \ref mackey::AdditiveStructure "AdditiveStructure" computes the homology of all spheres in a given range as Mackey functors. 

Example:

      AdditiveStructure<group_t> A({-3,-4},{5,6});

computes the homology of all spheres \f$S^{n\sigma+m\lambda}\f$ with \f$-3\leq n\leq 5, -4\leq m\leq 6\f$.

@note For \f$C_4\f$ the sphere \f$S^{n\sigma+m\lambda}\f$ is represented by a vector ```{n,m}```  . More generally for \f$C_{2^n}\f$ the sphere \f$S^{t_1\sigma+\sum_it_i\lambda_i}\f$ is represented by ```{t_1,...,t_n}```. This is specified in \ref C2n.hpp.

To print all Mackey functors \f$H_{\star}\f$ in the universal notation (see \ref mack) and for \f$\star\f$ in the aforementioned range, use:

      std::cout << A << "\n";

The answer is of the form

    The k=-9 homology of the -1,-4 sphere is 112#01

which means \f[H_{-9}(S^{-\sigma-4\lambda})= 112\#01\f]

in our "universal notation".

You can survey the identified Mackey functors by:

	std::cout << "The identified Mackey functors are: " << A.identified() << "\n\n\n\n";

(this will print one Mackey functor from each each equivalence class)

\subsection fact Factorization

The class \ref mackey::Factorization "Factorization" computes the multiplication graph (see the page \ref factor) given the "basic irreducibles". 

In this case let us use \f$a_{\sigma},u_{2\sigma},a_{\lambda},u_{\lambda}\f$ as our irreducibles:

	std::vector<std::vector<int>> basic_irr = { {0, 1, 0}, {2, 2, 0}, {0, 0, 1}, {2, 0, 1} };
	std::vector<std::string> basic_irr_names = {"asigma", "u2sigma", "alambda", "ulambda"};

@note For any group \f$G\f$, the degree of an element in \f$H_kS^V\f$ is represented by a vector ```{k,t1,...,tn}``` where ```{t1,...,tn}``` represents \f$S^V\f$.

To compute the multiplication graph in the range \f$S^{n\sigma+m\lambda}\f$, $-5\leq n,m\leq 5$, use:

	auto F = Factorization<group_t>(2, {-5, -5}, {5, 5}, basic_irr, basic_irr_names);

The \c 2 here signifies that we work on the top level of \f$C_4\f$.

@note For a group \f$G=C_{p^n}\f$ the level corresponding to \f$C_{p^n}/C_{p^i}\f$ corresponds to the integer \f$i\f$.

Then 

	F.compute_with_sources({{0, 0, 0}}, {"1"});

computes the factorizations by connecting every node in the multiplication graph to \f$1\f$ (if possible). To print the generator at degree \f$[3,1,0]\f$ use:

	std::cout << "The generator(s) at degree 3,1,0 is (are): " << F.getname({ -2,-2,0 }) << "\n\n";
	  
@note \ref mackey::Factorization::getname() "getname" returns a vector of strings as opposed to a single string, in case there are multiple generators in
the given degree (i.e. if the homology group is not cyclic), 

@warning You need to make sure the vector you are passing to \ref mackey::Factorization::getname() "getname" is within the range of spheres in the construction of \c F. This can be done using \ref mackey::Factorization::degreewithinrange "degreewithinrange"

To print the names of all generators use:

	std::cout << F << "\n\n";

The answer will be of the form

    At degree -4,-2,-1 we have: 1*4/(u2sigma*ulambda)

or of the form:

    At degree -7,-4,-4 we have: ???

The ```???``` means that the generator could not be obtained by multiplying/dividing the basic irreducibles with ```1```. 
This means that additional sources may be needed. To include the generator of \f$H_{-3}S^{-2\lambda}\f$ as our source we use:

      F.compute_with_sources({{0,0,0},{-3,0,-2}}, {"1","s"});

where now both \f$1\f$ and \f$s\f$ are used as sources. With that extra source, the code

	std::cout << F << "\n\n";

won't produce any ```???```.

To print the multiplication graph to a file and in the dot format use


	std::ofstream file;
	file.open("multgraph.dot");
	file << F.graph;
	file.close();

You can also print the shortest path tree to a file, which will be much simpler than the entire multiplication graph

	file.open("shortestpaths.dot");
	file << F.shortest_paths;
	file.close();

The .dot files can be rendered to .svg files using Graphviz.


\subsection mult Multiplying generators

The class \ref mackey::Factorization "Factorization" works by multiplying all generators of \f$H_\star\f$ in a given range.

To multiply two specific generators together we use the function \ref mackey::ROGreen "ROGreen". Example:

	auto linear_combination = ROGreen<group_t>(2, {-4, -2, -1}, {2, 0,  1});

performs the operation

\f[ H_0^{C_4}(S^{2\sigma-2\lambda}) \otimes H_{-4}^{C_4}(S^{-2\sigma-\lambda}) \to H_{-2}^{C_4}(S^{-2\sigma}) 
\\ a\otimes b\mapsto ab\f]

where \f$a,b\f$ are generators of the respective homology groups. Here: 

* The first argument of \ref mackey::ROGreen "ROGreen" indicates the level the generators live in.

* The second and third arguments are the degrees of the two generators \f$a,b\f$.

* The result of the computation ```linear_combination``` is a row vector \f$[t_0,...,t_k]\f$ of integer entries representing that: 
\f[ab=\sum_it_ig_i\f]
where \f$g_i\f$ are the generators of the homology group the product lives in.

In our case \f$H_{-2}^{C_4}(S^{-2\sigma}) \f$ is cyclic so \c linear_combination has length \f$1\f$.

Using the \ref mackey::Factorization "Factorization" object \c F from the previous examples, we can actually print the names of the generators being multiplied 
and the name of the generator in the degree of the product:

	std::cout << F.getname({ -4,-2,-1 }) << " * " << F.getname({ 2,0,1 }) << " = ";
	std::cout << linear_combination[0] << " * " << F.getname({ -2,-2,0 });

which will print out that:

\f[\frac{4}{u_{2\sigma}u_{\lambda}}\cdot u_{\lambda}= 2\cdot \frac{2}{u_{2\sigma}}\f]

@note If the homology in the degrees of \f$a\f$ or \f$b\f$ is not cyclic, then we select \f$a,b\f$ by providing two ```int``` arguments in \ref mackey::ROGreen "RO::Green". 
For example, providing \f$1,2\f$ selects the second and third generators \f$a,b\f$ of the noncyclic groups respectively.

\subsection mass Massey products

The method \ref mackey::ROMassey "ROMassey" computes (triple) Massey products in the Green functor \f$H_{\star}\f$. Example: 

      auto Mass= mackey::ROMassey<group_t>(2,{0,1,0},{-3,-3,0},{2,2,0});

computes the Massey product \f$\langle a_{\sigma},w_3,u_{2\sigma}\rangle \f$ and its indeterminacy.

As with the multiplicative structure, the Massey product is expressed in terms of a linear combination of the basis in the homology of the box product.
But there's also indeterminacy to worry about. In this case, 

      std::cout << Mass.indeterminacy;

prints out 1, so there is no indeterminacy, and we can print out the answer by:

		std::cout << "<" << F.getname({ 0, 0, 3 }) << " , " << F.getname({ -3, 0, -2 }) << " , ";
		std::cout << F.getname({ 2, 0, 1 }) << "> = " << Mass.basis[0] << " * " << F.getname({ 0,0,2 }); 

since the homology at degree ```{0,0,2}``` is cyclic (otherwise ```Mass.basis``` is a vector of size >1).

@note We can also provide three optional ```int``` arguments at the end for selections, analogous to what we did in \ref mult (see \ref mackey::Massey "Massey" for more details).


\subsection bey Higher order groups

For groups beyond \f$C_4\f$ it's possible for various identifications to fail. So let us set

	typedef C8<int64_t> group2_t;

for \f$C_8\f$ with \f$\mathbf Z\f$ coefficients. 

Then the code 

	AdditiveStructure<group2_t> A2({ -3, -3,-3 }, { 3, 3,3 });
	std::cout << A2 << "\n\n";

can also produce output like:

	The k=3  homology of the 3,1,-1 sphere is unknown 5

This means that the program couldn't write \f$H_{3}(S^{3\sigma+\lambda_0-\lambda_1})\f$ in the "universal notation" and instead named it unknown Mackey functor with id 5. To print out the Mackey functor structure, us:

	std::cout << "The unknown 5 is =\n" << A2.unknown()[5].print()<< "\n\n";


The case of \ref mackey::Factorization "Factorization" is even worse, and generally requires triple box products in order for identifications to work.

On the other hand, if only the connectivity of the multiplication graph is desired, there is a specialized \ref mackey::MultConnectivity "MultConnectivity" for that exact purpose.

Example:

	typedef std::vector<std::vector<int>> vv;
	typedef std::vector<std::string> vs;
	vv basic_irr2 = { {0,1,0,0},{0,0,1,0},{0,0,0,1},{2,2,0,0},{2,0,1,0},{2,0,0,1} };
	vs basic_names2 = { "a2","a4","a8","u2","u4","u8" };
	vv sources2 = { {0,0,0,0}, {-3,0,0,-2} };
	vs source_names2 = { "1", "s"};

These are the sources and irreducibles for \f$C_8\f$. Running

	auto F2 = Factorization<group2_t>(3, std::vector{ -5,-5,-5 }, std::vector{ 5, 5, 5 }, basic_irr2, basic_names2);
	F2.compute_with_sources(sources2, source_names2);
	std::cout << F2.disconnected_degrees().size() << "\n\n";

will print out 49, which is the number of generators that couldn't be connected to \f$1\f$ or \f$s\f$ due to identification problems.

On the other hand:

	auto MC = MultConnectivity<group2_t>(3, std::vector{ -5,-5,-5 }, std::vector{ 5, 5, 5 }, basic_irr2);
	MC.compute_with_sources(sources2);
	std::cout << MC.disconnected_degrees.size() << "\n";

will produce \f$0\f$, since the identification of the aforementioned generators is irrelevant as far as the connectivity is concerned.

\subsection serial Serialization

In many cases it is desirable to save computational results in cold storage and
then load them back as needed. 

This library achieves serialization by calling the cereal library, which you'll need to include in your path. The serialization methods are found in the header \ref Cerealizer.hpp so start with:

	#include Serialization/Cerealizer.hpp

For example, say we have a \ref mackey::Factorization "Factorization" object ```F``` that we want to save to a binary file. We can do that by:

	save(F,"filename");

This actually saves the parent class \ref mackey::MultTableData "MultTableData" as opposed to the factorization object, since the fundamental data are in that class. As such, to load it use:

	MultTableData<group_t> M;
	load(M,"filename");

@note The template parameter ```group_t``` must match with the template parameter of the saved object.

We can then construct ```F``` from ```M``` by:

	Factorization<group_t> Fnew(std::move(M),basic_irr_names);

(the names of the basic irreducibles are not part of the data that was serialized). Then ```Fnew``` and ```F``` will be identical.

\page ext Extensions
\tableofcontents
\section grp Extending the group

The library natively supports all groups \f$G=C_{2^n}\f$ but can easily be extended to \f$G=C_{p^n}\f$ for prime \f$p\f$.\n
The input remaining is \f$C_*(S^V)\f$ for \f$V\f$ a \em non-virtual \f$G\f$-rep. See \ref C2n.hpp or \ref C4.hpp for examples. 

@note The algorithm used in \ref C2n.hpp is based on the recursion established in HHR17 pg 392

@todo Implement all \f$G=C_{p^n}\f$


For general cyclic groups the subgroup diagram is not a vertical tower so the transfer and restriction algorithms will need reworking to take that into account

@todo Support arbitrary cyclic groups by using a subgroup diagram-tree for transfers and restrictions

For more general finite abelian groups we would also need to specify the order of the elements of the group and how they relate to the subgroup diagram to form our equivariant bases.

@todo Support general finite abelian groups

\section coeff Extending the coefficients

The library natively supports \f$\mathbf Z\f$ and \f$\mathbf Z/p\f$ constant coefficients. See \ref Z_n.hpp for the implementation of the latter.

For non constant coefficients transferring becomes much more complicated as the modules involved in the free Mackey functors are no longer of the form \f$\oplus_HR[G/H]\f$.

@todo Support non constant coefficients such as Burnside ring coefficients \f$A_{\mathbf Z}\f$

\page algo Beneath the surface
\tableofcontents

\section dvs Dense vs sparse

The differential matrices can be stored in either dense or sparse formats.
* A dense matrix is an array representation of a matrix where all values are stored. For a matrix with \f$n\f$ many rows and columns this means space complexity:
\f[O(n^2)\f]
* A sparse matrix is an array representation of a matrix where only the nonzero values and their indices are stored. For a matrix with \f$n\f$ many rows and columns and \f$r\f$ many nonzero elements this means space complexity:
\f[O(n\cdot r)\f]

For this library, it is necessary to use sparse matrices for groups beyond \f$C_4\f$; the reason is that for \f$C_8\f$ and above,
matrices can have millions of rows and columns but are 99\% zeros. Using the dense format can easily mean memory usage north of 60GB.

Using sparse matrices has an interesting side-effect that we explain in the next section.

\section smith Smith normal form

There are multiple ways to compute the Smith Normal Form of a matrix, but since we are mostly interested in the coefficient matrices, we employ the
row/column elimination algorithm. To use the algorithm we need to be able to choose a pivot for our matrix each time we want to eliminate a row and column.

The pivoting choice is quite important for two reasons:

* Coefficient explosion (applies to infinite base rings): Even if the entries of the matrix are small (\f$\pm 1\f$),
the entries of the Smith Normal Form (and especially those of the coefficient matrices) can easily overflow if we make the wrong choice of pivot.
You can read more about this problem in  <a href="https://arxiv.org/abs/math/9406205">Recognizing badly presented Z modules</a>.

* Fill-in (applies to all base rings): A wrong choice of pivot may result in creating nonzero entries, making our matrix less sparse. 

The strategy we employ is to pick the pivot so as to minimize two criteria:

* 1: absolute value. This is only relevant over infinite base rings like \f$\mathbf Z\f$
* 2: the Markowitz metric 
\f[N(i,j)=|\{a_{is}\neq 0: s\}| + |\{a_{sj}\neq 0:s\}|\f]
This is an upper bound to the amount of fill-in one can get by a single round of row/column elimination.

There are many other possible choices as explained  <a href="https://arxiv.org/abs/math/9406205">here</a>.

@note Over fields we use partial pivoting instead of full pivoting i.e. we perform only column eliminations and 
get a triangular matrix at the end.

\section amt Algebraic Morse theory

It is possible to reduce a chain complex to a homotopy equivalent chain complex that's smaller, using algebraic Morse theory (AMT). See this 
<a href="https://arxiv.org/pdf/1903.00783.pdf">paper</a> for more details and an implementation of the AMT algorithm. 

An elaboration on the ideas of that paper allows us to perform the reduction while preserving equivariance. This effectively means that whenever we have a box product \f$C_*\otimes D_*\f$ we can replace it by an equivalent equivariant chain complex \f$T_*\f$ that is significantly smaller. There are two upsides:

* Overall lower memory usage and better performance, especially in the Smith Normal Form algorithm
* We can reduce triple box products to double box products:
\f[C_*\otimes D_*\otimes E_*=T_*\otimes E_*\f]
The RHS is significantly smaller than the LHS and can be further compressed by using the equivariant AMT algorithm on it.

@todo Further explore/improve the equivariant AMT algorithm.

\section equiv Equivariant chain complexes

Our chain complexes don't consist of \f$R\f$-modules but rather \f$R[G]\f$ modules of the form 
\f[\oplus_H R[G/H]\f]

To record the equivariant information we use rank arrays: for example consider
 \f[\mathbf Z[C_4]\text{ vs } \mathbf Z[C_2]\oplus \mathbf Z[C_2]\f]
 We say that the former has rank \f$[4]\f$ while the latter has rank \f$[2,2]\f$,

Moreover, a basis over \f$R[G]\f$ expands to an \f$R\f$ basis that we call equivariant; that's a basis where each generator is followed by its orbit:

\f[x_1,gx_1,...,g^{s_1}x_1,x_2,gx_2,....,g^{s_n}x_n\f]

with \f$g^{s_i+1}x_i=1\f$.

We need to use equivariant bases to transfer our differentials from the bottom level to higher levels.

\section box Box products

The differential of the tensor product of chain complexes can be pictured as:

\n

\image html diagram4.svg

\n

where

\f[L_i(x\otimes y)=d_ix\otimes y\text{ , }R_i(x\otimes y)=(-1)^{|x|}x\otimes d_i'y\f]

The matrix for the differential is:

\f[d^{\otimes}=\begin{pmatrix}R_0&L_1\\&R_1&L_2&\\ &&\ddots&\ddots\\&&&R_{k-1}&L_{k-1}\end{pmatrix}\f]

and it remains to compute the matrix expressions of every \f$L,R\f$.\n
Given bases for \f$C_j, D_k\f$ we can form two lexicographical bases for \f$C_j\otimes D_k\f$; one of them we call left convenient because \f$L\f$ is block diagonal w.r.t. it (each block being \f$d\f$); the other we call right convenient because \f$R\f$ is block diagonal w.r.t. it (each block being \f$d'\f$).

However, we aren't allowed to use these bases in \f$d^{\otimes}\f$: we have \em equivariant chain complexes and we need \em equivariant bases for them. We refer to the equivariant basis for the tensor product as the canonical basis.\n

For example if \f$A,B\f$ have equivariant bases \f$a,ga,g^2a,g^3a\f$ and \f$b,gb\f$ respectively then the left convenient, right convenient and canonical bases are respectively:
\f[
a\otimes b\text{ , }ga\otimes b\text{ , }g^2a\otimes b\text{ , } g^3\otimes b\text{ , } a\otimes gb\text{ , } ga\otimes gb \text{ , } g^2a\otimes gb \text{ , }g^3a \otimes gb\\
a\otimes b\text{ , }a\otimes gb\text{ , }ga\otimes b  \text{ , } ga\otimes gb\text{ , } g^2a\otimes b\text{ , } g^2a\otimes gb \text{ , } g^3a\otimes b  \text{ , } g^3a\otimes gb\\
a\otimes b\text{ , }g(a\otimes b)\text{ , }g^2(a\otimes b)\text{ , }g^3(a\otimes b)\text{ , } a\otimes gb\text{ , } g(a\otimes gb)\text{ , }g^2(a\otimes gb)\text{ , } g^3(a\otimes gb)\f]

We can compute the change of basis matrices between these three bases, and using them allows us to write \f$L,R\f$ w.r.t. the canonical basis. This is how \f$d^{\otimes}\f$ is obtained.