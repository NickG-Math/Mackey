<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mackey: From Math to Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mackey
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A C++ library for computing the RO(G) homology of a point</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('math.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">From Math to Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Briefly"></a>
Briefly</h1>
<p>There are three fundamental ideas that make our code work:</p>
<ul>
<li>Homology of chain complexes of free \(\mathbb Z\) modules can be algorithmically computed by turning the differentials into matrices and then diagonalizing them (Smith Normal Form).</li>
<li>Free <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors are determined by their bottom level groups. The higher levels are obtained by taking fixed points, and this can be done algorithmically on our matrices as long as equivariant bases are used (this is an ordered basis in which elements in the same orbit are written consecutively).</li>
<li>Box products of <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors are tensor products on the bottom level. This is not true for the higher levels, however using the bulletpoint above, higher levels are obtained by transferring. This is how box products of chain complexes of free <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors are computed.</li>
</ul>
<p>These three ideas dictate our approach: We work primarily on the bottom level, before transferring to get the higher ones. Homology is computed in each level separately and transfers/restrictions/Weyl group actions on the generators can be computed on the chains. But the chains are always free, so we can also algorithmically compute the effect of transfers/restrictions and Weyl group actions.</p>
<p>By converting all our differentials to matrices, using equivariant bases throughout, we can reduce our computations to pure linear algebra (over the integers), avoiding any symbolic math.</p>
<h1><a class="anchor" id="imd"></a>
In more detail</h1>
<p>Here's how the code works in more detail (for simplicity we specialize to the \(G=C_4\) case, although everything works with different prime powers:</p>
<h2><a class="anchor" id="add"></a>
The additive structure</h2>
<ul>
<li>The input are the bottom levels of the chains of the spheres \(S^{n\sigma+m\lambda}\) for \(n,m\ge 0\). We could in fact do with only \(S^{\sigma},S^{\lambda}\), but this would result in taking arbitrarily many box products and destroy performance. Instead using the spheres \(S^{n\sigma+m\lambda}\) for \(n,m\ge 0\) we only have to take triple box products at most, for some of the multiplicative structure.</li>
<li>The data of a Chain complex are the ranks and differentials. The differentials are stored as matrices, but the ranks are stored as integer arrays and not integers. This is crucial as for example \(\mathbb Z[C_4]\) transfers completely differently from \(\mathbb Z[C_2]\oplus \mathbb Z[C_2]\) even though they both have rank \(4=2+2\) over \(\mathbb Z\). With our conventions, \(\mathbb Z[C_2]\oplus \mathbb Z[C_2]\) has rank \([2,2]\) while \(\mathbb Z[C_4]\) has rank \(4\).</li>
<li>We transfer both ranks and differentials to higher levels. While transferring ranks is straightforward, transferring differentials is quite a bit more complicated and requires to have already transferred the ranks of the domain and range of the differentials.</li>
<li>Using the familiar homology algorithm we compute the groups of the <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functor at every level. We also compute their generators (as elements in the Chain complex)</li>
<li>We transfer/restrict and compute the Weyl group action on the group generators. This concludes the <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functor computation for the \(S^{n\sigma+m\lambda}\), \(n,m\ge 0\).</li>
<li>To obtain the chains of the rest of the spheres, we box the Chains we already have. Boxing is more complicated compared to just taking tensor products, as we have to use equivariant bases throughout to transfer properly. However the most convenient bases for tensoring are not equivariant, and in the end we have to change bases through permutation matrices.</li>
<li>We then perform the same procedure with transferring to get the entrire \(RO(G)\) homology.</li>
</ul>
<h2><a class="anchor" id="mult"></a>
The multiplicative structure</h2>
<p>Once we have the additive structure, we can work on multiplying the additive generators.</p>
<ul>
<li>First we restrict the generators to the bottom level.</li>
<li>We then take the product of their restrictions as an element of the box product of chain complexes at bottom level.</li>
<li>The product of restrictions is a restriction and as we are working with free <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors, restriction is an injection. By inverting it we can get the product of generators at a higher level as element an of the box product.</li>
<li>We finally take homology and write that product in terms of the generators.</li>
</ul>
<p>Once we know how to multiply any two additive generators, we have in effect determined the multiplicative structure (see below for a catch).</p>
<h2><a class="anchor" id="factor"></a>
Factorization</h2>
<p>Even if we can multiply any two generators, that doesn't mean we can automatically write any element as a product of our preferred generators. If we know the expression then we can easily check it, however factorizing is a lot more complicated:</p>
<ul>
<li>First we form a multiplication table, where all generators (in a range of course) are multiplied with the "basic irreducibles". These can be the Euler and orientation classes.</li>
<li>Once we have that we can draw a directed colored graph by connecting \(a\) with \(ab\) for \(b\) a basic irreducible; we color this edge red. If multiplication by b is an isomorphism i.e. \(a=(ab)/b\) then we also connect \(ab\) with \(a\); we color this edge blue.</li>
<li>Since the product \(ab\) may not be a generator, but rather a multiple of it, we need to allow multiples of generators as distinct nodes. We never allow trivial (0) multiples of generators.</li>
<li>To obtain a factorization, we simply need to connect 1 with any node in the graph. For the most efficient factorizations, we want to minimize the alternation of blue and red edges. This is done by a generalized Dikjstra algorithm.</li>
<li>For the generators not connected to 1 (eg \(s_3\)) we perform the same process using different sources for our graph.</li>
</ul>
<h1><a class="anchor" id="caveat"></a>
A caveat</h1>
<h2><a class="anchor" id="cyclic"></a>
Cyclic Generators</h2>
<ul>
<li>The way we prove that say a transfer map is multiplication by \(2\), is by computing the generators at the domain and target, compute the transfer of the domain generator and compare with the target. Of course, there are usually multiple choices of generators, but up to isomorphism we get the same <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functor.</li>
<li>There is a caveat however that appears when computing the multiplicative structure: If we prove that \(ab\) and \(cd\) are both generators of the same cyclic group, then we can't conclude that they are equal. Eg if the group is \(\mathbb Z/4\) or \(\mathbb Z\) then they differ by a sign. Still, since we are interested in generating the \(RO(G)\) homology, as opposed to finding exact relations, we don't have to distinguish between cyclic generators and we don't need to stress over this detail.</li>
<li>If we are interested in exact relations, then we can resolve the multiple generator ambiguity as follows: \(ab\) and \(cd\) are produced by tensoring different complexes, and if we have an explicit chain homotopy between them then we can compare directly. For example if they are obtained by tensoring \(C_*(S^{n\sigma+m\lambda})\otimes C_*S^{\lambda}\) and \(C_*(S^{n\sigma+(m-1)\lambda})\otimes C_*S^{2\lambda}\) then we can compare them by using \(C_*(S^{n\sigma+(m-1)\lambda})\otimes C_*S^{\lambda}\otimes C_*S^{\lambda}\) as a stepping stone.</li>
<li>The problem with the above approach is that we need to take more and more box products, which is the most costly operation for runtime.</li>
</ul>
<h2><a class="anchor" id="noncycl"></a>
Non cyclic generators</h2>
<ul>
<li>There is a situtation where this caveat cannot be sidestepped and that's when we have non cyclic groups. Here's an example where this problem comes up: If we have \(\mathbb Z\oplus \mathbb Z/2\) with generators \(x,y\) respectively then we can't automatically distinguish \(x\) from \(x+y\) as there is an automorphism of \(\mathbb Z\oplus \mathbb Z/2\) exchanging them. In that case the difference between \(ab\) and \(cd\) generating the same group can be much more severe than multiplication with an integer coprime to the group's order (or a sign).</li>
<li>One way out of this is to apply the approach for cyclic generators, breaking down our box products further, until they can be compared.</li>
<li>Alternatively (and this is the approach we take in practice) is to ignore these products and make no statement as to the equality of \(ab\) and \(cd\). This gives us less data to work with, but at least in the \(C_4\) case this is enough to write the factorization of any element. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
