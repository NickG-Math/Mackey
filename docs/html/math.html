<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mackey: From Math to Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mackey
   &#160;<span id="projectnumber">V3.1</span>
   </div>
   <div id="projectbrief">A C++ library for computing RO(G) graded homology</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">From Math to Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#nut">In a nutshell</a></li>
<li class="level1"><a href="#br">Briefly</a></li>
<li class="level1"><a href="#mean">Obtaining a useful output</a><ul><li class="level2"><a href="#mack">&quot;Universal&quot; Mackey functor notation</a></li>
<li class="level2"><a href="#iso">Isomorphic Mackey functors</a></li>
<li class="level2"><a href="#factor">Factorization</a></li>
</ul>
</li>
<li class="level1"><a href="#caveat">A caveat</a><ul><li class="level2"><a href="#cyclic">Cyclic Generators</a></li>
<li class="level2"><a href="#noncyclic">Non cyclic generators</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="nut"></a>
In a nutshell</h1>
<p>The aim of this library is to solve the following problem:<br  />
Given inputs:</p><ul>
<li>\(G\) = the ambient group eg \(C_4\).</li>
<li>\(R\) = the base PID with trivial \(G\)-action eg \(\mathbf Z\) or \(\mathbf Z/p\).</li>
<li>\(X\) = a \(G\)-CW space eg a point or \(B_{C_4}\Sigma_2\).</li>
<li>The bottom level chain complexes \(C_*^e(S^V)\) corresponding to finite \(G\)-CW decompositions of \(S^V\) where \(V\) ranges over all real <em>non-virtual</em> \(G\)-reps.</li>
<li>The bottom level chain complex \(C_*^e(X)\) corresponding to a finite \(G\)-CW decomposition of \(X\).</li>
</ul>
<p>produce output:</p>
<ul>
<li>The \(RO(G)\) graded homology \(H_{\star}(X)\) and cohomology \(H^{\star}(X)\) as Mackey functor modules over the Green functor \(H_{\star}\).</li>
</ul>
<p>The library can also compute Massey products \(\langle a,b,c\rangle\) for \(a,b,c\in H_{\star}\) with \(ab=bc=0\).</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>\(X=B_{C_4}\Sigma_2\) is an infinite dimensional CW-complex so we replace it by the finite skeleta \(B_{C_4}\Sigma_2(j)\).</li>
<li>Computing the multiplicative structure (including Massey products) involves comparing generators from homotopy equivalent chain complexes. This is not always possible without an explicit chain homotopy (see <a class="el" href="math.html#caveat">A caveat</a>).</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="br"></a>
Briefly</h1>
<p>What enables this library to work is that free Mackey functors are determined on their bottom level by transferring:</p>
<ul>
<li>By a "free Mackey functor" we mean a finite sum of the form: <p class="formulaDsp">
\[\oplus_H\underline{R[G/H]}\]
</p>
 where \(H\) ranges over (conjugacy classes of) subgroups of \(G\) (we allow repetitions).</li>
<li>For a free Mackey functor \(M\) we have \(M(G/H)=M(G/e)^H\).</li>
</ul>
<p>An application of this: box products of free Mackey functors are tensor products on the bottom level. This is not true for the higher levels, however we can obtain those by transferring. The same applies to duals.</p>
<p>Our approach that starts with \(C_*^e(X), C_*^e(S^V)\) and computes \(H_{\star}(X)\) can be summarized in the following diagram (in the case of \(G=C_4\)):</p>
<p><br  />
<br  />
 </p><div class="image">
<object type="image/svg+xml" data="diagram2.svg" style="pointer-events: none;"></object>
</div>
<p><br  />
<br  />
 </p><dl class="section note"><dt>Note</dt><dd>Cohomology can be computed in the same way by first dualizing \(C_*^e(X)\) to get \(C^*_e(X)\). So in what follows we will only discuss the homology case.</dd></dl>
<p>To fully computerize this approach we make the following modifications:</p>
<ul>
<li>We replace all chain complex differentials with matrices.</li>
<li>Tensor/dual/transfer/homology all correspond to operations on matrices. For example homology is computed via the Smith Normal Form algorithm.</li>
<li>The generators of each level of \(H_{\star}(X)\) are reductions of explicit elements on \(C_{\star}(X)\). This means that we can compute the effect of transfer/restriction/Weyl group action on them (by performing the computation on \(C_{\star}(X)\)), giving us the Mackey functor structure of \(H_{\star}(X)\).</li>
</ul>
<p>We multiply the additive generators of \(H_{\star}\) by performing the tensor/cross product on the chain level. This involves restricting and then inverting restrictions (which is possible since we have free Mackey functors). Diagrammatically:</p>
<p><br  />
<br  />
 </p><div class="image">
<object type="image/svg+xml" data="diagram3.svg" style="pointer-events: none;"></object>
</div>
<p><br  />
<br  />
</p>
<p>We similarly compute Massey products in \(H_{\star}\) and the module structure of \(H_{\star}(X)\) over \(H_{\star}\).</p>
<h1><a class="anchor" id="mean"></a>
Obtaining a useful output</h1>
<p>Let us take \(G=C_{p^n}\) and \(R=\mathbf Z\).</p>
<h2><a class="anchor" id="mack"></a>
"Universal" Mackey functor notation</h2>
<p>While a Mackey functor is determined by the level-wise groups, transfers, restrictions and Weyl group actions, it is desirable to have a "universal" notation to concisely describe any Mackey functor.</p>
<ul>
<li>The notation <p class="formulaDsp">
\[a_0...a_n \sharp b_0...b_m\]
</p>
 describes the Mackey functor \(M\): <p class="formulaDsp">
\[M(C_{p^n}/C_{p^i})=\begin{cases}\mathbf Z/a_i&amp;\text{ if }a_i\neq 1\\ \mathbf Z&amp;\text{ if }a_i= 1\end{cases} \\ Tr_{{p^i}}^{{p^{i+1}}}(x)=\begin{cases}x&amp;\text{ if }i=b_j\text{ for some }j\\ 2x&amp;\text{ else }\end{cases}\\ Res_{{p^i}}^{{p^{i+1}}}(x)=\begin{cases}2x&amp;\text{ if }i=b_j\text{ for some }j\\x&amp;\text{ else }\end{cases}\]
</p>
 Here we assume \(0\leq b_0&lt;\cdots&lt;b_m&lt;n\). The Weyl group actions are determined by the double coset formula.</li>
<li>More generally we extend the notation linearly to define arbitrary finite sums: <p class="formulaDsp">
\[a_0...a_n \sharp b_0...b_m + \cdots + c_0...c_n\sharp d_0...d_l\]
</p>
</li>
<li>For \(G=C_4\), every Mackey functor can be written in this notation. For \(G=C_8\) and \(\mathbf Z\) coefficients there are three exceptional Mackey functors that can't be expressed in our "universal" notation.</li>
</ul>
<h2><a class="anchor" id="iso"></a>
Isomorphic Mackey functors</h2>
<p>Isomorphic Mackey functors can have different "universal" notations. To find if two different notations correspond to isomorphic Mackey functors (and are thus equivalent), it suffices to compute all different notations in each isomorphism class.</p>
<p>Given a Mackey functor \(M\) we compute its isomorphism class as follows:</p>
<ul>
<li>For each level \(M(G/H)\) we find all automorphisms \(Aut(M(G/H))\).</li>
<li>Choosing one automorphism for each \(H\) gives a Mackey functor automorphism of \(M\) (as long as the level-wise choices commute with restrictions/transfers/Weyl group actions). This gives \(Aut(M)\).</li>
<li><p class="startli">For finitely generated (abelian) groups with only one \(\mathbf Z\) factor, there are only finitely many automorphisms and we can easily classify them all.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Make identification work even if there is more than one \(\mathbf Z\) factor (so we get infinitely many automorphisms)</dd></dl>
</li>
</ul>
<h2><a class="anchor" id="factor"></a>
Factorization</h2>
<p>Starting with a small group of generators, the factorization process tries to write every other generator in terms of them. <br  />
It goes as follows:</p>
<ul>
<li>First we form a multiplication table, where all generators (in a range) are multiplied with the "basic irreducibles". These basic irreducibles can be the Euler and orientation classes.</li>
<li>We then get a directed colored graph by drawing \(a\color{red}{\to} ab\) for \(b\) a basic irreducible.</li>
<li>If multiplication by \(b\) is an isomorphism i.e. \(a=(ab)/b\) then we also draw \(ab\color{blue}{\to} a\)</li>
<li>Since the product \(ab\) may not be a generator, but rather a multiple of it, we need to allow nonzero multiples of generators as distinct nodes.</li>
<li>To obtain a factorization, we simply need to connect 1 with any node in the graph.</li>
<li>For the most efficient factorizations, we want to minimize the number of times we alternate between blue and red edges in each path. For example consider: <p class="formulaDsp">
\[\frac{ab}{cd}\text{ vs } \frac{a \frac{b}{c}}{d}\]
</p>
 We also want to minimize the total length of the paths. This is done by a modified Dijkstra algorithm.</li>
<li>For the generators not connected to 1 (eg \(s\)) we need to perform the same process using different sources for our graph (eg using \(s\) as the source for all paths).</li>
</ul>
<h1><a class="anchor" id="caveat"></a>
A caveat</h1>
<h2><a class="anchor" id="cyclic"></a>
Cyclic Generators</h2>
<ul>
<li>The way we prove that a transfer map is (say) multiplication by \(2\), is by computing the generators at the domain and target, computing the transfer of the domain generator and comparing with the target. Of course, there are usually multiple choices of generators, but up to isomorphism we get the same Mackey functor.</li>
<li>There is a catch however that appears when computing the multiplicative structure: If we prove that \(ab\) and \(cd\) are both generators of the same cyclic group, then we can't conclude that they are equal. Eg if the group is \(\mathbf Z/4\) or \(\mathbf Z\) then they may differ by a sign.</li>
<li>Since we are interested in generating the \(RO(G)\) homology, as opposed to finding exact relations, we don't have to distinguish between cyclic generators so we don't need to worry about this detail.</li>
<li>If we are interested in exact relations, then are ways to resolve the ambiguity as we explain in the following subsection.</li>
</ul>
<h2><a class="anchor" id="noncyclic"></a>
Non cyclic generators</h2>
<ul>
<li>There is a situation where the caveat above cannot be worked-around and that's when we have non cyclic groups. <br  />
A typical example: <p class="formulaDsp">
\[\mathbf Z\{x,y\}/2y=\mathbf Z\oplus \mathbf Z/2= \mathbf Z\{x+y,y\}/2y\]
</p>
 and we can't distinguish \(x\) from \(x+y\) as there is an automorphism of \(\mathbf Z\oplus \mathbf Z/2\) exchanging them.</li>
<li><p class="startli">Another example: Over \(\mathbf F_2\) coefficients we can't distinguish the three generators of</p>
<p class="formulaDsp">
\[\mathbf F_2\oplus \mathbf F_2\]
</p>
</li>
<li>One way out of this is to break down our box products further until they can be directly compared. For example: <p class="formulaDsp">
\[S^{2\sigma+\lambda}\wedge S^{-\lambda}=S^{\sigma}\wedge S^{\sigma}\wedge S^{\lambda}\wedge S^{-\lambda}S^{\sigma+\lambda}\wedge S^{\sigma -\lambda}\]
</p>
 This is difficult to program generally and comes at a very high performance cost as we need more iterated box products.</li>
<li>Another way is to use the fact that we actually have extensions of Mackey functors, not just group extensions. So for example if we have <p class="formulaDsp">
\[Tr:\mathbf Z\to \mathbf Z\{x,y\}/2y\\ Tr(1)=x\]
</p>
 then we can distinguish \(x\) from \(x+y\) as only the former is a transfer.</li>
<li>This doesn't always work: We can have <p class="formulaDsp">
\[Res: \mathbf F_2\{x,y\}\to \mathbf F_2\\ Res(x)=0\text{ , }Res(y)=1\\ Tr:\mathbf F_2\to \mathbf F_2\{x,y\}\\ Tr(1)=0\]
</p>
 in which case we cannot distinguish between \(y\) and \(x+y\).</li>
<li>There is one final trick that can help in the case above: If for some element \(z\) we can distinguish \(xz\) and \((x+y)z\) then this also distinguishes \(x,x+y\).</li>
<li>In practice, for \(\mathbf Z\) coefficients and \(G=C_4\) we can choose to ignore these problems and not draw any edges if we can't distinguish generators; this gives us less data to work with, but it turns out to be sufficient in writing the factorization of any element.</li>
<li>That doesn't work for \(\mathbf F_2\) coefficients and \(G=C_4\), or \(\mathbf Z\) coefficients and \(G=C_8\), as there are simply too many instances of noncyclic groups. Instead we need to use all the tricks above to identify our generators and factorize every element.</li>
<li><p class="startli">If we are only interested in the connectivity of the multiplication graph (whether or not everything is generated by Euler+orientation classes) then we don't need to make all identifications as connecting \(a\to x\) or \(a\to x+y\) gives graphs with the same number of components.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Implement Frobenius relations: The multiplicative structure is computed levelwise, but this could be done more effectively using the Frobenius relations </dd></dl>
<p class="formulaDsp">
\[Tr(Res(x)y)=xTr(y)\]
</p>
 </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
