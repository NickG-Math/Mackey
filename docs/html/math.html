<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mackey: From Math to Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mackey
   &#160;<span id="projectnumber">V2.1</span>
   </div>
   <div id="projectbrief">A C++ library for computing the RO(G) homology of a point</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('math.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">From Math to Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Briefly">Briefly</a></li>
<li class="level1"><a href="#imd">In more detail</a><ul><li class="level2"><a href="#add">The additive structure</a></li>
<li class="level2"><a href="#mack">Recognizing Mackey Functors</a></li>
<li class="level2"><a href="#mult">The multiplicative structure</a></li>
<li class="level2"><a href="#factor">Factorization</a></li>
<li class="level2"><a href="#Mass">Massey Products</a></li>
</ul>
</li>
<li class="level1"><a href="#caveat">A caveat</a><ul><li class="level2"><a href="#cyclic">Cyclic Generators</a></li>
<li class="level2"><a href="#noncycl">Non cyclic generators</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="Briefly"></a>
Briefly</h1>
<p>There are three fundamental ideas that make the code work:</p>
<ul>
<li>Homology of chain complexes of free \(\mathbb Z\) modules can be algorithmically computed by turning the differentials into matrices and then diagonalizing them (Smith Normal Form).</li>
<li>Free <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors are determined by their bottom level groups. The higher levels are obtained by taking fixed points, and this can be done algorithmically on our matrices by writing them with respect to equivariant bases (an equivariant basis is an ordered basis in which elements in the same orbit are written consecutively).</li>
<li>Box products of <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors are tensor products on the bottom level. This is not true for the higher levels, however using the bulletpoint above, higher levels are obtained by transferring. This is how box products of chain complexes of free <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors are computed.</li>
</ul>
<p>These three ideas dictate our approach: We work primarily on the bottom level, before transferring to get the higher ones. Homology is computed in each level separately and transfers/restrictions/Weyl group actions on the generators can be computed on the chains. But the chains are always free, so we can also algorithmically compute the effect of these operations.</p>
<p>By converting all our differentials to matrices, using equivariant bases throughout, we can reduce our computations to pure linear algebra (over the integers), avoiding any symbolic math.</p>
<h1><a class="anchor" id="imd"></a>
In more detail</h1>
<p>Here's how the code works in more detail (for simplicity we specialize to the \(G=C_4\) case, although everything works equally well with general prime powers):</p>
<h2><a class="anchor" id="add"></a>
The additive structure</h2>
<ul>
<li>The inputs are the bottom levels of the chains of the spheres \(S^{n\sigma+m\lambda}\) for \(n,m\ge 0\). We could do away with only \(S^{\sigma},S^{\lambda}\), but this would result in taking arbitrarily many box products and devastate run-time performance. Instead, if we use the spheres \(S^{n\sigma+m\lambda}\) for \(n,m\ge 0\) we only have to take double box products at worst, and that's only for part of the multiplicative structure.</li>
<li>The data of a chain complex are the ranks and differentials. The differentials are stored as matrices, but the ranks are stored as integer arrays and not integers. This is crucial as for example \(\mathbb Z[C_4]\) transfers completely differently from \(\mathbb Z[C_2]\oplus \mathbb Z[C_2]\) even though they both have rank \(4=2+2\) over \(\mathbb Z\). With our conventions, \(\mathbb Z[C_2]\oplus \mathbb Z[C_2]\) has rank \([2,2]\) while \(\mathbb Z[C_4]\) has rank \(4\).</li>
<li>We transfer both ranks and differentials to higher levels. While transferring ranks is straightforward, transferring differentials is quite a bit more complicated and requires to have already transferred the ranks of the domain and range of the differentials.</li>
<li>Using the classical homology algorithm we compute the groups of the <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functor at every level. We also compute their generators (as elements in the chain complex)</li>
<li>We transfer/restrict and compute the Weyl group action on the group generators. This concludes the <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functor computation for the \(S^{n\sigma+m\lambda}\), \(n,m\) having the same sign (if \(n,m&lt;0\) we take the dual chain complex, which has the effect of switching all differentials to their transposes).</li>
<li>To obtain the chains of the rest of the spheres, we box the Chains we already have. Boxing is more complicated compared to just taking tensor products, as we have to use equivariant bases throughout to transfer properly. However the most convenient bases for tensoring are not equivariant, and in the end we have to change bases through permutation matrices.</li>
<li>We then perform the same procedure on these chains to get the entrire \(RO(G)\) homology as a (graded) <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functor.</li>
</ul>
<h2><a class="anchor" id="mack"></a>
Recognizing Mackey Functors</h2>
<p>While a <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functor is determined by the groups, transfers, restrictions and Weyl group actions, it is desirable to have a "universal notation" to concisely describe them. Here's the notation we use:</p>
<ul>
<li>First assume all levels are cyclic groups, transfers are multiplication by 2 and corresponding restrictions are multiplication by 1 or vice-versa. Then the notation \(a_1...a_n \sharp b_1...b_m\) means that the levels are \(\mathbb Z/a_i\)or \(\mathbb Z\) if \(a_i=1\) and the transfers at levels \(b_i\) are multiplication by 1, and multiplication by 2 for the rest. The Weyl group action is then determined by the double coset formula.</li>
<li>For <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors that are sums of Mackeys of this form we use the plus operator to concatenate the notations.</li>
<li>For \(C_4\) this notation suffices to describe every <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a>, but for \(C_8\) there are three exceptional <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors.</li>
</ul>
<p>For the second item, summing <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors is straightforward (block diagonal matrices). The problem is showing that two <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors are isomorphic (as opposed to equal). To do that, we collect all automorphisms of the groups in each level and apply them as a natural transformation to our <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functor and obtain its isomorphism class. So to check if two <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors are isomorphic, we check if one is equal to a <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functor in the equivalence class of the other.</p>
<ul>
<li>For finitely generated (abelian) groups with only one \(\mathbb Z\) factor, there are only finitely many automorphisms and we can easily classify them all.</li>
<li>If there is more than one \(\mathbb Z\) factor, there are infinitely many automorphisms, so the user must provide those that the program should use for the identification.</li>
</ul>
<h2><a class="anchor" id="mult"></a>
The multiplicative structure</h2>
<p>Once we have the additive structure (minus the recognition part), we can work on multiplying the additive generators.</p>
<ul>
<li>First we restrict the generators to the bottom level.</li>
<li>We then take the product of their restrictions as an element of the box product of chain complexes at bottom level.</li>
<li>The product of restrictions is a restriction and as we are working with free <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors, restriction is an injection. By inverting it we can get the product of generators at a higher level as an element of the box product.</li>
<li>We finally take homology of the resulting chains and write that product in terms of the generators of the homology.</li>
</ul>
<p>Once we know how to multiply any two additive generators, we have in effect determined the multiplicative structure (see <a class="el" href="math.html#caveat">A caveat</a> for a catch).</p>
<h2><a class="anchor" id="factor"></a>
Factorization</h2>
<p>Even if we can multiply any two generators, that doesn't mean we can automatically write any element as a product of our preferred generators. Verifying that for example the generator of \(H_{-2}S^{-2\sigma}\) is \(2/u_{2\sigma}\), is simple enough; coming up with the expression of the generator is a lot more complicated. This is done automatically by the factorization process:</p>
<ul>
<li>First we form a multiplication table, where all generators (in a range) are multiplied with the "basic irreducibles". These basic irreducibles can be the Euler and orientation classes.</li>
<li>Once we have the table we can draw a directed colored graph by drawing the edges \(a\to ab\) for \(b\) a basic irreducible; we color these edges red. If multiplication by \(b\) is an isomorphism i.e. \(a=(ab)/b\) then we also connect \(ab\to a\); we color such edges blue.</li>
<li>Since the product \(ab\) may not be a generator, but rather a multiple of it, we need to allow nonzero multiples of generators as distinct nodes.</li>
<li>To obtain a factorization, we simply need to connect 1 with any node in the graph. For the most efficient factorizations, we want to minimize the number we alternate between blue and red edges in each path. This is done by a modified Dikjstra algorithm.</li>
<li>For the generators not connected to 1 (eg \(s_3\)) we need to perform the same process using different sources for our graph (eg using \(s_3\) as the source for all paths).</li>
</ul>
<h2><a class="anchor" id="Mass"></a>
Massey Products</h2>
<p>The chains based approach we use means that Massey products can be computed from definition. The only extra thing we need is the following:</p>
<ul>
<li>Given an element \(x\) that vanishes in homology we can find a \(y\) that bounds it: \(dy=x\). This is part of our homology algorithm.</li>
</ul>
<p>So Massey products work like this:</p>
<ul>
<li>Suppose we have \(ab=bc=0\) in homology. We lift \(a,b,c\) to chains \(C,D,E\) and explicitly compute \(ab, bc\) in \(C\otimes D\) and \(D\otimes E\) respectively, as in <a class="el" href="math.html#mult">The multiplicative structure</a>.</li>
<li>After that we find \(ds=ab, dt=bc\) and form \(sc\) and \(at\) in the box products \((C\otimes D) \otimes E\) and \(C\otimes (D\otimes E)\) respectively.</li>
<li>These box products are isomorphic up to a permutation that we can explicitly compute. Thus we can write \(sc\) and \(at\) as elements of the same chain complex in the same basis.</li>
<li>Finally we form \(sc+(-1)^{|a|+|b|+1}at\) and compute its image in homology.</li>
</ul>
<h1><a class="anchor" id="caveat"></a>
A caveat</h1>
<h2><a class="anchor" id="cyclic"></a>
Cyclic Generators</h2>
<ul>
<li>The way we prove that say a transfer map is multiplication by \(2\), is by computing the generators at the domain and target, computing the transfer of the domain generator and comparing with the target. Of course, there are usually multiple choices of generators, but up to isomorphism we get the same <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functor.</li>
<li>There is a catch however that appears when computing the multiplicative structure: If we prove that \(ab\) and \(cd\) are both generators of the same cyclic group, then we can't conclude that they are equal. Eg if the group is \(\mathbb Z/4\) or \(\mathbb Z\) then they differ by a sign. Still, since we are interested in generating the \(RO(G)\) homology, as opposed to finding exact relations, we don't have to distinguish between cyclic generators and we don't need to worry about this detail.</li>
<li>If we are interested in exact relations, then are ways to resolve the ambiguity as we explain in the following subsection.</li>
</ul>
<h2><a class="anchor" id="noncycl"></a>
Non cyclic generators</h2>
<ul>
<li>There is a situtation where the caveat above cannot be sidestepped and that's when we have non cyclic groups. A typical example: If we have \(\mathbb Z\oplus \mathbb Z/2\) with generators \(x,y\) respectively then we can't automatically distinguish \(x\) from \(x+y\) as there is an automorphism of \(\mathbb Z\oplus \mathbb Z/2\) exchanging them. In that case the difference between \(ab\) and \(cd\) generating the same group can be much more severe than just an integer coprime to the group's order (or a sign).</li>
<li>For another example, when computing the \(RO(C_4)\) homology in \(\mathbb F_2\) coefficients the group \(\mathbb F_2\oplus \mathbb F_2\) tends to appear frequently; unfortunately the three generators cannot be distingusihed.</li>
<li>One way out of this is to break down our box products further until they can be directly compared. This is difficult to program generally and comes at a very high performance cost as we need more iterated box products.</li>
<li>Another way is to use the fact that these noncyclic homology groups result from extensions of <a class="el" href="namespaceMackey.html" title="The namespace for everything that is group-independent. ">Mackey</a> functors, not just group extensions. So for example in \(\mathbb Z\oplus \mathbb Z/2\) we can distinguish \(x\) from \(x+y\) using that \(x\) is a transfer. This doesn't always work: We can have a \(\mathbb F_2\oplus \mathbb F_2\) generated by \(x,y\) with \(x\) having restriction \(0\) while \(y\) having restriction \(1\) and no generator being a transfer; in this case we cannot distinguish between \(y\) and \(x+y\).</li>
<li>There is one final trick we can use to resolve this ambiguity as it appears the Factorization algorithm: Assume we have \(ab=x\) or \(ab=x+y\) using the notation in the bullet above. For each element \(z\) we can compute the products \(xz\) and \((x+y)z\). If for some \(z\) they are different and can be distingusihed, then we can form \(abz\) internally (triple box product) and compare the answer to \(xz\) and \((x+y)z\); we then divide by \(z\) to find what \(ab\).</li>
</ul>
<p>In practice, for \(\mathbb Z\) coefficients and \(G=C_4\) we can choose to ignore the products we can't identify and make no statement as to the equality of \(ab\) and \(cd\) if they live in non cyclic groups. This gives us less data to work with, but at least in that case this is enough to write the factorization of any element.</p>
<p>For \(G=C_8\) ignoring them won't work as we have many more instances of noncyclic groups. Instead we need to use all the bulletpoints above to identify our generators and factorize every element.</p>
<p>If we are only interested in the connectivity of the multiplication graph (everything being generated by Euler+orientation classes...) then we don't need to make all identifications: If \(ab\) is \(x\) or \(x+y\) and \(x,y\) are connected to the source of the graph and multiplication by \(b\) is an injection on \(a\), then it doesn't matter if the answer is \(x\) or \(x+y\): in both cases, \(a\) is also connected to the source. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
