<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mackey: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mackey
   &#160;<span id="projectnumber">V3.3</span>
   </div>
   <div id="projectbrief">A C++ library for computing RO(G) graded homology</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tuto.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#incl">Includes</a></li>
<li class="level1"><a href="#name">Namespaces</a></li>
<li class="level1"><a href="#temp">Template parameters</a></li>
<li class="level1"><a href="#next">Code Examples</a><ul><li class="level2"><a href="#add">The additive structure</a></li>
<li class="level2"><a href="#fact">Factorization</a></li>
<li class="level2"><a href="#mult">Multiplying generators</a></li>
<li class="level2"><a href="#mass">Massey products</a></li>
<li class="level2"><a href="#bey">Higher order groups</a></li>
<li class="level2"><a href="#serial">Serialization</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The code examples here can be compiled from the .cpp file in the <a href="https://github.com/NickG-Math/Mackey/tree/master/demo">demo</a> folder.</p>
<h1><a class="anchor" id="incl"></a>
Includes</h1>
<p>Many parts of the library can be individually included. To keep things simple, we provide a single header file <a class="el" href="Mackey_8hpp.html">Mackey.hpp</a> that includes the entire library (and Eigen)</p>
<dl class="section attention"><dt>Attention</dt><dd>If you are using MSVC, including Eigen will give compilation errors unless you define the following macro: <div class="fragment"><div class="line">#define _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS </div>
</div><!-- fragment --> Make sure to define the macro <em>before</em> including <a class="el" href="Mackey_8hpp.html">Mackey.hpp</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>To enable multithreading via openMP define the macro <code>MACKEY_USE_OPENMP</code> before including <a class="el" href="Mackey_8hpp.html">Mackey.hpp</a> and enable openMP in your compiler (on Clang and GCC this is done by the flag <code>-fopenmp</code>)</dd></dl>
<p>With that in mind, we start with: </p><pre class="fragment">  #include "Mackey.hpp"
</pre> <h1><a class="anchor" id="name"></a>
Namespaces</h1>
<p>Everything in this library is under the namespace <a class="el" href="namespacemackey.html">mackey</a>. For the following code examples we use: </p><pre class="fragment">  using namespace mackey;
</pre> <h1><a class="anchor" id="temp"></a>
Template parameters</h1>
<p>The three template parameters that need to be set are the ambient group \(G\), the coefficient ring \(R\) and the \(G\)-space \(X\). For these examples let us use \(X=*\) which supports all of the library's features.</p>
<p>From the get-go the library provides support for:</p>
<ul>
<li>groups \(G=C_{2^n}\) via the class <a class="el" href="structmackey_1_1C2Power.html">C2Power</a></li>
<li>fields \(\mathbf Z/p\) via the class <a class="el" href="classmackey_1_1Z__mod.html">Z_mod</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The ring \(\mathbf Z\) corresponds to the usual signed integer types eg <code>int64_t</code> so there's no need to define a wrapper around it (64bit accuracy is more than enough for these computations, and you can use an overflow sanitizer to protect against it).</dd></dl>
<p>For example <code>C2Power&lt;5,Z_mod&lt;3&gt;&gt;</code> is the type corresponding to group \(C_{2^5}\) and coefficients \(\mathbf Z/3\).<br  />
Another example: <code>C2Power&lt;1,int64_t&gt;</code> corresponds to group \(C_2\) and coefficients \(\mathbf Z\) with 64bit range.</p>
<dl class="section note"><dt>Note</dt><dd>We provide convenient typedefs for \(C_2,C_4,C_8,C_{16}\) via the classes <a class="el" href="namespacemackey.html#a28cd2cfa99eec14e29e4596270e19e57">C2</a>, <a class="el" href="namespacemackey.html#af8c93d5fa3f77d0b96aed94af65294cf">C4</a>, <a class="el" href="namespacemackey.html#a779c0ba0ea4888716f87242e6eb1b7a1">C8</a>, <a class="el" href="namespacemackey.html#a6580bfc2d37b874fc88c517d0e32232e">C16</a>.</dd>
<dd>
We provide a convenient typedef for \(\mathbf Z/2\) via <a class="el" href="namespacemackey.html#a04d0601e31671015025369bfd66d798d">Z2</a>.</dd></dl>
<p>For the following examples we shall use the configuration: </p><pre class="fragment">  typedef C4&lt;int64_t&gt; group_t;
</pre><p> which means \(\mathbf Z\) coefficients and group \(C_4\).</p>
<h1><a class="anchor" id="next"></a>
Code Examples</h1>
<h2><a class="anchor" id="add"></a>
The additive structure</h2>
<p>The class <a class="el" href="classmackey_1_1AdditiveStructure.html">AdditiveStructure</a> computes the homology of all spheres in a given range as Mackey functors.</p>
<p>Example: </p><pre class="fragment">  AdditiveStructure&lt;group_t&gt; A({-3,-4},{5,6});
</pre><p> computes the homology of all spheres \(S^{n\sigma+m\lambda}\) with \(-3\leq n\leq 5, -4\leq m\leq 6\).</p>
<dl class="section note"><dt>Note</dt><dd>For \(C_4\) the sphere \(S^{n\sigma+m\lambda}\) is represented by a vector <code>{n,m}</code> . More generally for \(C_{2^n}\) the sphere \(S^{t_1\sigma+\sum_it_i\lambda_i}\) is represented by <code>{t_1,...,t_n}</code>. This is specified in <a class="el" href="C2n_8hpp.html">C2n.hpp</a>.</dd></dl>
<p>To print all Mackey functors \(H_{\star}\) in the universal notation (see <a class="el" href="math.html#mack">"Universal" Mackey functor notation</a>) and for \(\star\) in the aforementioned range, use: </p><pre class="fragment">  std::cout &lt;&lt; A &lt;&lt; "\n";
</pre><p> The answer is of the form </p><pre class="fragment">The k=-9 homology of the -1,-4 sphere is 112#01
</pre><p> which means </p><p class="formulaDsp">
\[H_{-9}(S^{-\sigma-4\lambda})= 112\#01\]
</p>
<p>in our "universal notation".</p>
<p>You can survey the identified Mackey functors by: </p><pre class="fragment">std::cout &lt;&lt; "The identified Mackey functors are: " &lt;&lt; A.identified() &lt;&lt; "\n\n\n\n";
</pre><p> (this will print one Mackey functor from each each equivalence class)</p>
<h2><a class="anchor" id="fact"></a>
Factorization</h2>
<p>The class <a class="el" href="classmackey_1_1Factorization.html">Factorization</a> computes the multiplication graph (see the page <a class="el" href="math.html#factor">Factorization</a>) given the "basic irreducibles".</p>
<p>In this case let us use \(a_{\sigma},u_{2\sigma},a_{\lambda},u_{\lambda}\) as our irreducibles: </p><pre class="fragment">std::vector&lt;std::vector&lt;int&gt;&gt; basic_irr = { {0, 1, 0}, {2, 2, 0}, {0, 0, 1}, {2, 0, 1} };
std::vector&lt;std::string&gt; basic_irr_names = {"asigma", "u2sigma", "alambda", "ulambda"};
</pre> <dl class="section note"><dt>Note</dt><dd>For any group \(G\), the degree of an element in \(H_kS^V\) is represented by a vector <code>{k,t1,...,tn}</code> where <code>{t1,...,tn}</code> represents \(S^V\).</dd></dl>
<p>To compute the multiplication graph in the range \(S^{n\sigma+m\lambda}\), $-5\leq n,m\leq 5$, use: </p><pre class="fragment">auto F = Factorization&lt;group_t&gt;(2, {-5, -5}, {5, 5}, basic_irr, basic_irr_names);
</pre><p> The <code>2</code> here signifies that we work on the top level of \(C_4\).</p>
<dl class="section note"><dt>Note</dt><dd>For a group \(G=C_{p^n}\) the level corresponding to \(C_{p^n}/C_{p^i}\) corresponds to the integer \(i\).</dd></dl>
<p>Then </p><pre class="fragment">F.compute_with_sources({{0, 0, 0}}, {"1"});
</pre><p> computes the factorizations by connecting every node in the multiplication graph to \(1\) (if possible). To print the generator at degree \([3,1,0]\) use: </p><pre class="fragment">std::cout &lt;&lt; "The generator(s) at degree 3,1,0 is (are): " &lt;&lt; F.getname({ -2,-2,0 }) &lt;&lt; "\n\n";
</pre> <dl class="section note"><dt>Note</dt><dd><a class="el" href="classmackey_1_1Factorization.html#a283b966e7d1e7658d2b482ab4f651510">getname</a> returns a vector of strings as opposed to a single string, in case there are multiple generators in the given degree (i.e. if the homology group is not cyclic),</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You need to make sure the vector you are passing to <a class="el" href="classmackey_1_1Factorization.html#a283b966e7d1e7658d2b482ab4f651510">getname</a> is within the range of spheres in the construction of <code>F</code>. This can be done using <a class="el" href="classmackey_1_1MultTable.html#ab2a29eaea7365624a4c36256c3b4bcb5">degreewithinrange</a></dd></dl>
<p>To print the names of all generators use: </p><pre class="fragment">std::cout &lt;&lt; F &lt;&lt; "\n\n";
</pre><p> The answer will be of the form </p><pre class="fragment">At degree -4,-2,-1 we have: 1*4/(u2sigma*ulambda)
</pre><p> or of the form: </p><pre class="fragment">At degree -7,-4,-4 we have: ???
</pre><p> The <code>???</code> means that the generator could not be obtained by multiplying/dividing the basic irreducibles with <code>1</code>. This means that additional sources may be needed. To include the generator of \(H_{-3}S^{-2\lambda}\) as our source we use: </p><pre class="fragment">  F.compute_with_sources({{0,0,0},{-3,0,-2}}, {"1","s"});
</pre><p> where now both \(1\) and \(s\) are used as sources. With that extra source, the code </p><pre class="fragment">std::cout &lt;&lt; F &lt;&lt; "\n\n";
</pre><p> won't produce any <code>???</code>.</p>
<p>To print the multiplication graph to a file and in the dot format use</p>
<pre class="fragment">std::ofstream file;
file.open("multgraph.dot");
file &lt;&lt; F.graph;
file.close();
</pre><p> You can also print the shortest path tree to a file, which will be much simpler than the entire multiplication graph </p><pre class="fragment">file.open("shortestpaths.dot");
file &lt;&lt; F.shortest_paths;
file.close();
</pre><p> The .dot files can be rendered to .svg files using Graphviz.</p>
<h2><a class="anchor" id="mult"></a>
Multiplying generators</h2>
<p>The class <a class="el" href="classmackey_1_1Factorization.html">Factorization</a> works by multiplying all generators of \(H_\star\) in a given range.</p>
<p>To multiply two specific generators together we use the function <a class="el" href="namespacemackey.html#aea2a61da5e12dcf121d300b60617eca4">ROGreen</a>. Example: </p><pre class="fragment">auto linear_combination = ROGreen&lt;group_t&gt;(2, {-4, -2, -1}, {2, 0,  1});
</pre><p> performs the operation</p>
<p class="formulaDsp">
\[ H_0^{C_4}(S^{2\sigma-2\lambda}) \otimes H_{-4}^{C_4}(S^{-2\sigma-\lambda}) \to H_{-2}^{C_4}(S^{-2\sigma}) \\ a\otimes b\mapsto ab\]
</p>
<p>where \(a,b\) are generators of the respective homology groups. Here:</p>
<ul>
<li>The first argument of <a class="el" href="namespacemackey.html#aea2a61da5e12dcf121d300b60617eca4">ROGreen</a> indicates the level the generators live in.</li>
<li>The second and third arguments are the degrees of the two generators \(a,b\).</li>
<li>The result of the computation <code>linear_combination</code> is a row vector \([t_0,...,t_k]\) of integer entries representing that: <p class="formulaDsp">
\[ab=\sum_it_ig_i\]
</p>
 where \(g_i\) are the generators of the homology group the product lives in.</li>
</ul>
<p>In our case \(H_{-2}^{C_4}(S^{-2\sigma}) \) is cyclic so <code>linear_combination</code> has length \(1\).</p>
<p>Using the <a class="el" href="classmackey_1_1Factorization.html">Factorization</a> object <code>F</code> from the previous examples, we can actually print the names of the generators being multiplied and the name of the generator in the degree of the product: </p><pre class="fragment">std::cout &lt;&lt; F.getname({ -4,-2,-1 }) &lt;&lt; " * " &lt;&lt; F.getname({ 2,0,1 }) &lt;&lt; " = ";
std::cout &lt;&lt; linear_combination[0] &lt;&lt; " * " &lt;&lt; F.getname({ -2,-2,0 });
</pre><p> which will print out that:</p>
<p class="formulaDsp">
\[\frac{4}{u_{2\sigma}u_{\lambda}}\cdot u_{\lambda}= 2\cdot \frac{2}{u_{2\sigma}}\]
</p>
<dl class="section note"><dt>Note</dt><dd>If the homology in the degrees of \(a\) or \(b\) is not cyclic, then we select \(a,b\) by providing two <code>int</code> arguments in <a class="el" href="namespacemackey.html#aea2a61da5e12dcf121d300b60617eca4">RO::Green</a>. For example, providing \(1,2\) selects the second and third generators \(a,b\) of the noncyclic groups respectively.</dd></dl>
<h2><a class="anchor" id="mass"></a>
Massey products</h2>
<p>The method <a class="el" href="namespacemackey.html#a652275fee4fde5df8fa9a4e576656a41">ROMassey</a> computes (triple) Massey products in the Green functor \(H_{\star}\). Example: </p><pre class="fragment">  auto Mass= mackey::ROMassey&lt;group_t&gt;(2,{0,1,0},{-3,-3,0},{2,2,0});
</pre><p> computes the Massey product \(\langle a_{\sigma},w_3,u_{2\sigma}\rangle \) and its indeterminacy.</p>
<p>As with the multiplicative structure, the Massey product is expressed in terms of a linear combination of the basis in the homology of the box product. But there's also indeterminacy to worry about. In this case, </p><pre class="fragment">  std::cout &lt;&lt; Mass.indeterminacy;
</pre><p> prints out 1, so there is no indeterminacy, and we can print out the answer by: </p><pre class="fragment">    std::cout &lt;&lt; "&lt;" &lt;&lt; F.getname({ 0, 0, 3 }) &lt;&lt; " , " &lt;&lt; F.getname({ -3, 0, -2 }) &lt;&lt; " , ";
    std::cout &lt;&lt; F.getname({ 2, 0, 1 }) &lt;&lt; "&gt; = " &lt;&lt; Mass.basis[0] &lt;&lt; " * " &lt;&lt; F.getname({ 0,0,2 }); 
</pre><p> since the homology at degree <code>{0,0,2}</code> is cyclic (otherwise <code>Mass.basis</code> is a vector of size &gt;1).</p>
<dl class="section note"><dt>Note</dt><dd>We can also provide three optional <code>int</code> arguments at the end for selections, analogous to what we did in <a class="el" href="tuto.html#mult">Multiplying generators</a> (see <a class="el" href="classmackey_1_1Massey.html">Massey</a> for more details).</dd></dl>
<h2><a class="anchor" id="bey"></a>
Higher order groups</h2>
<p>For groups beyond \(C_4\) it's possible for various identifications to fail. So let us set </p><pre class="fragment">typedef C8&lt;int64_t&gt; group2_t;
</pre><p> for \(C_8\) with \(\mathbf Z\) coefficients.</p>
<p>Then the code </p><pre class="fragment">AdditiveStructure&lt;group2_t&gt; A2({ -3, -3,-3 }, { 3, 3,3 });
std::cout &lt;&lt; A2 &lt;&lt; "\n\n";
</pre><p> can also produce output like: </p><pre class="fragment">The k=3  homology of the 3,1,-1 sphere is unknown 5
</pre><p> This means that the program couldn't write \(H_{3}(S^{3\sigma+\lambda_0-\lambda_1})\) in the "universal notation" and instead named it unknown Mackey functor with id 5. To print out the Mackey functor structure, us: </p><pre class="fragment">std::cout &lt;&lt; "The unknown 5 is =\n" &lt;&lt; A2.unknown()[5].print()&lt;&lt; "\n\n";
</pre><p>As for factorization, let us use the following basic irreducibles and sources over \(C_8\): </p><pre class="fragment">typedef std::vector&lt;std::vector&lt;int&gt;&gt; vv;
typedef std::vector&lt;std::string&gt; vs;
vv basic_irr2 = { {0,1,0,0},{0,0,1,0},{0,0,0,1},{2,2,0,0},{2,0,1,0},{2,0,0,1} };
vs basic_names2 = { "a2","a4","a8","u2","u4","u8" };
vv sources2 = { {0,0,0,0}, {-3,0,0,-2} };
vs source_names2 = { "1", "s"};
</pre><p> Then </p><pre class="fragment">auto F2 = Factorization&lt;group2_t&gt;(3, {-5,-5,-5 }, { 5, 5, 5 }, basic_irr2, basic_names2);
F2.compute_with_sources(sources2, source_names2);
std::cout &lt;&lt; F2.disconnected_degrees().size() &lt;&lt; "\n\n";
</pre><p> will print out 49, which is the number of generators that couldn't be connected to \(1\) or \(s\). There are two reasons that caused this:</p>
<ul>
<li>The generators are close to the edge of the range of spheres hence multiplying them by the basic irreducibles takes the products outside of the range so they are not considered</li>
<li>Due to the presence of noncyclic groups, the program was not able to identify these generators (see <a class="el" href="math.html#caveat">A caveat</a>).</li>
</ul>
<p>The solution to the first problem is to increase the range of the spheres being used. To solve the second problem, we use triple products (see <a class="el" href="math.html#caveat">A caveat</a>) via: </p><pre class="fragment">F2.pass_unidentified();
</pre><p> Once we do that, </p><pre class="fragment">std::cout &lt;&lt; F2.disconnected_degrees().size() &lt;&lt; "\n\n";
</pre><p> will print out 5.</p>
<p>Finally, if only the connectivity of the multiplication graph is desired, there is a specialized <a class="el" href="classmackey_1_1MultConnectivity.html">MultConnectivity</a> class for that exact purpose.<br  />
For example, </p><pre class="fragment">auto MC = MultConnectivity&lt;group2_t&gt;(F2);
MC.compute_with_sources(sources2);
std::cout &lt;&lt; MC.disconnected_degrees.size() &lt;&lt; "\n";
</pre><p> will print \(0\), which means that all generators are connected to \(1,s\).</p>
<h2><a class="anchor" id="serial"></a>
Serialization</h2>
<p>In many cases it is desirable to save computational results in cold storage and then load them back as needed.</p>
<p>This library achieves serialization by calling the cereal library, which you'll need to include in your path. The serialization methods are found in the header <a class="el" href="Cerealizer_8hpp.html">Cerealizer.hpp</a> so start with: </p><pre class="fragment">#include Serialization/Cerealizer.hpp
</pre><p> For example, say we have a <a class="el" href="classmackey_1_1Factorization.html">Factorization</a> object <code>F</code> that we want to save to a binary file. We can do that by: </p><pre class="fragment">save(F,"filename");
</pre><p> This actually saves the parent class <a class="el" href="structmackey_1_1MultTableData.html">MultTableData</a> as opposed to the factorization object, since the fundamental data are in that class. As such, to load it use: </p><pre class="fragment">MultTableData&lt;group_t&gt; M;
load(M,"filename");
</pre> <dl class="section note"><dt>Note</dt><dd>The template parameter <code>group_t</code> must match with the template parameter of the saved object.</dd></dl>
<p>We can then construct <code>F</code> from <code>M</code> by: </p><pre class="fragment">Factorization&lt;group_t&gt; Fnew(std::move(M),basic_irr_names);
</pre><p> (the names of the basic irreducibles are not part of the data that was serialized). Then <code>Fnew</code> and <code>F</code> will be identical. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
