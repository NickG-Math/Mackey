\mainpage General Information
\tableofcontents
 \section intro Introduction
This is a C++ header only library devoted to numerically computing the \f$RO(G)\f$ homology of a point. You can find the GitHub repository <a href="https://github.com/NickG-Math/Mackey">here</a>.

For a quick demonstration in the case of \f$G=C_4\f$ you can use one of the available binaries <a href="https://github.com/NickG-Math/Mackey/tree/master/bin">here</a>.


\section req Requirements
 * C++17 and the standard library.
 * <a href=" http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>, a header only library for matrix manipulation. I've tested the code with Eigen 3.3.7 though newer versions shouldn't break compatibility.
 * Optional: For improved performance you can use the Intel MKL with Eigen and further combine with OpenMP for multithreading.
 * Optional: To draw the multiplication graphs you will need Graphviz.
 
\section install Installation

* To install simply clone/download the <a href="https://github.com/NickG-Math/Mackey">repository</a> and include it in your path. You will also need to do the same with Eigen.

* See the page \ref use for a tutorial on using the library.

* As for compiler support, I have tested the code with the following C++ compilers: GCC 9.2 (Linux), Clang 10 (Linux and MacOS), Intel Compiler 19 (Linux and Windows), MSVC 19 (Windows). Remember to use the option ```-std=c++17```. For more information on compiler options, see the \ref perf page.

\section status Current Status

* The project is almost complete for \f$G\f$ a cyclic group of prime power order. The only input that's needed are the equivariant chains at the bottom level for the spheres corresponding to actual representations or their opposites; we call these "standard chains". 
The standard chains can be easily computed from geometric equivariant decompositions by hand, and then fed into the program as explained in \ref how. 
It might be worth it to automate this process as well; after all, the differentials of the standard chains can all be obtained using the fact that the homology at the bottom level has to be trivial apart from top dimension.

* The one thing that hasn't been implemented for prime-power cyclic groups are Frobenius relations: 
The multiplicative structure is computed levelwise, but this could be made more effective using the Frobenius relations. 

* For general cyclic groups a few aspects that involve transferring need reworking. 
The problem is that non prime-power cyclic groups the diagram of subgroups is not a vertical tower but a somewhat more complicated diagram, so care has to be taken to account for all these extra transfers and restrictions. 
Ultimately this is the only part that needs changing.

* The bulletpoint above also applies to general finite abelian groups. We also need to specify the order of the elements of the group and how they relate to the subgroup diagram to form our equivariant bases.

* For non abelian groups we have the added complication of needing the real representation theory of our group. And of course we need the standard chains for these groups as well. 

* For non constant coefficients a lot more things start to break, as transferring becomes more complicated when non cyclic modules are involved in the free Mackey functors.

\section doc Documentation

This documentation is organized in pages as follows:
 
* The  <a href="namespaces.html">Related pages</a> consist of the pages \ref index, \ref math, \ref use, \ref algo, \ref perf. These explain how the program works, starting from the math and moving to slightly more technical territory regarding the actual implementation.

* The pages <a href="namespaces.html">Namespaces</a>, <a href="annotated.html">Classes</a>  and <a href="files.html">Files</a> are automatically generated by doxygen from the source code (and comments in the source code). These offer a much more indepth look into all classes and functions of this project. Note that only public and protected members and named namespaces are documented.

* I recommend starting with the <a href="namespaces.html">related pages</a> before moving to the automatically generated ones. If you just want to use this library for computations, you only really have to go over the \ref how section.


\page math From Math to Code
\tableofcontents
\section Briefly

There are three fundamental ideas that make the code work:

* Homology of chain complexes of free \f$\mathbb Z\f$ modules can be algorithmically computed by turning the differentials into matrices and then diagonalizing them (Smith Normal Form). 

* Free Mackey functors are determined by their bottom level groups. The higher levels are obtained by taking fixed points, and this can be done algorithmically on our matrices by writing them with respect to equivariant bases (an equivariant basis is an ordered basis in which elements in the same orbit are written consecutively).

* Box products of Mackey functors are tensor products on the bottom level. This is not true for the higher levels, however using the bulletpoint above, higher levels are obtained by transferring. This is how box products of chain complexes of free Mackey functors are computed.

These three ideas dictate our approach: We work primarily on the bottom level, before transferring to get the higher ones. Homology is computed in each level separately and transfers/restrictions/Weyl group actions on the generators can be computed on the chains. But the chains are always free, so we can also algorithmically compute the effect of these operations.

By converting all our differentials to matrices, using equivariant bases throughout, we can reduce our computations to pure linear algebra (over the integers), avoiding any symbolic math.


\section imd In more detail

Here's how the code works in more detail (for simplicity we specialize to the \f$G=C_4\f$ case, although everything works equally well with general prime powers):

\subsection add The additive structure

* The inputs are the bottom levels of the chains of the spheres \f$S^{n\sigma+m\lambda}\f$ for \f$n,m\ge 0\f$. We could do away with only \f$S^{\sigma},S^{\lambda}\f$, but this would result in taking arbitrarily many box products and devastate run-time performance. Instead, if we use the spheres  \f$S^{n\sigma+m\lambda}\f$ for \f$n,m\ge 0\f$ we only have to take double box products at worst, and that's only for part of the multiplicative structure.

* The data of a chain complex are the ranks and differentials. The differentials are stored as matrices, but the ranks are stored as integer arrays and not integers. This is crucial as for example \f$\mathbb Z[C_4]\f$ transfers completely differently from \f$\mathbb Z[C_2]\oplus \mathbb Z[C_2]\f$ even though they both have rank \f$4=2+2\f$ over \f$\mathbb Z\f$. 
With our conventions, \f$\mathbb Z[C_2]\oplus \mathbb Z[C_2]\f$ has rank \f$[2,2]\f$ while \f$\mathbb Z[C_4]\f$ has rank \f$4\f$.

* We transfer both ranks and differentials to higher levels. While transferring ranks is straightforward, transferring differentials is quite a bit more complicated and requires to have already transferred the ranks of the domain and range of the differentials.

* Using the classical homology algorithm we compute the groups of the Mackey functor at every level. We also compute their generators (as elements in the chain complex)

* We transfer/restrict and compute the Weyl group action on the group generators. This concludes the Mackey functor computation for the  \f$S^{n\sigma+m\lambda}\f$, \f$n,m\f$ having the same sign (if \f$n,m<0\f$ we take the dual chain complex, which has the effect of switching all differentials to their transposes).

* To obtain the chains of the rest of the spheres, we box the Chains we already have. Boxing is more complicated compared to just taking tensor products, as we have to use equivariant bases throughout to transfer properly. However the most convenient bases for tensoring are not equivariant, and in the end we have to change bases through permutation matrices.

* We then perform the same procedure on these chains to get the entrire \f$RO(G)\f$ homology as a (graded) Mackey functor.

\subsection mult The multiplicative structure

Once we have the additive structure, we can work on multiplying the additive generators. 

* First we restrict the generators to the bottom level.

* We then take the product of their restrictions as an element of the box product of chain complexes at bottom level.

* The product of restrictions is a restriction and as we are working with free Mackey functors, restriction is an injection. By inverting it we can get the product of generators at a higher level as an element of the box product.

* We finally take homology of the resulting chains and write that product in terms of the generators of the homology.

Once we know how to multiply any two additive generators, we have in effect determined the multiplicative structure (see \ref caveat for a catch).

\subsection factor Factorization

Even if we can multiply any two generators, that doesn't mean we can automatically write any element as a product of our preferred generators. Verifying that for example the generator of \f$H_{-2}S^{-2\sigma}\f$ is \f$2/u_{2\sigma}\f$, is simple enough; coming up with the expression of the generator is a lot more complicated. This is done automatically by the factorization process:

* First we form a multiplication table, where all generators (in a range) are multiplied with the "basic irreducibles". These basic irreducibles can be the Euler and orientation classes.

* Once we have the table we can draw a directed colored graph by drawing the edges \f$a\to ab\f$ for \f$b\f$ a basic irreducible; we color these edges red. If multiplication by \f$b\f$ is an isomorphism i.e. \f$a=(ab)/b\f$ then we also connect \f$ab\to a\f$; we color such edges blue.

* Since the product \f$ab\f$ may not be a generator, but rather a multiple of it, we need to allow multiples of generators as distinct nodes. On the other hand, we never allow trivial (0) multiples of generators.

* To obtain a factorization, we simply need to connect 1 with any node in the graph. For the most efficient factorizations, we want to minimize the number we alternate between blue and red edges in each path. 
This is done by a modified Dikjstra algorithm.

* For the generators not connected to 1 (eg \f$s_3\f$) we need to perform the same process using different sources for our graph (eg using \f$s_3\f$ as the source for all paths).

\subsection Mass Massey Products

The chains based approach we use means that Massey products can be computed from definition. The only extra thing we need is the following:

* Given an element \f$x\f$ that vanishes in homology we can find a \f$y\f$ that bounds it: \f$dy=x\f$. This is part of our homology algorithm.

So Massey products work like this:

* Suppose we have \f$ab=bc=0\f$ in homology. We lift \f$a,b,c\f$ to chains \f$C,D,E\f$ and explicitly compute \f$ab, bc\f$ in \f$C\otimes D\f$ and \f$D\otimes E\f$ respectively, as in \ref mult.

* After that we find \f$ds=ab, dt=bc\f$ and form \f$sc\f$ and \f$at\f$ in the box products \f$(C\otimes D) \otimes E\f$ and \f$C\otimes (D\otimes E)\f$ respectively.

* These box products are isomorphic up to a permutation that we can explicitly compute. Thus we can write \f$sc\f$ and \f$at\f$ as elements of the same chain complex in the same basis.

* Finally we form \f$sc+(-1)^{|a|+|b|+1}at\f$ and compute its image in homology.

\section caveat A caveat
\subsection cyclic Cyclic Generators

* The way we prove that say a transfer map is multiplication by \f$2\f$, is by computing the generators at the domain and target, computing the transfer of the domain generator and comparing with the target. 
Of course, there are usually multiple choices of generators, but up to isomorphism we get the same Mackey functor. 

* There is a catch however that appears when computing the multiplicative structure: If we prove that \f$ab\f$ and \f$cd\f$ are both generators of the same cyclic group, then we can't conclude that they are equal. 
Eg if the group is \f$\mathbb Z/4\f$ or \f$\mathbb Z\f$ then they differ by a sign. Still, since we are interested in generating the \f$RO(G)\f$ homology, as opposed to finding exact relations, we don't have to distinguish between cyclic generators and we don't need to worry about this detail.

* If we are interested in exact relations, then are ways to resolve the ambiguity as we explain in the following subsection.


\subsection noncycl Non cyclic generators

* There is a situtation where the caveat above cannot be sidestepped and that's when we have non cyclic groups. A typical example: 
If we have \f$\mathbb Z\oplus \mathbb Z/2\f$ with generators \f$x,y\f$ respectively then we can't automatically distinguish \f$x\f$ from \f$x+y\f$ as there is an automorphism of \f$\mathbb Z\oplus \mathbb Z/2\f$ exchanging them. 
In that case the difference between \f$ab\f$ and \f$cd\f$ generating the same group can be much more severe than just an integer coprime to the group's order (or a sign).

* For another example, when computing the \f$RO(C_4)\f$ homology in \f$\mathbb F_2\f$ coefficients the group \f$\mathbb F_2\oplus \mathbb F_2\f$ tends to appear frequently; unfortunately the three generators cannot be distingusihed.

* One way out of this is to break down our box products further until they can be directly compared. This is difficult to program generally and comes at a very high performance cost as we need more iterated box products.

* Another way is to use the fact that these noncyclic homology groups result from extensions of Mackey functors, not just group extensions. 
So for example in \f$\mathbb Z\oplus \mathbb Z/2\f$ we can distinguish \f$x\f$ from \f$x+y\f$ using that \f$x\f$ is a transfer. 
This doesn't always work: We can have a \f$\mathbb F_2\oplus \mathbb F_2\f$ generated by \f$x,y\f$  with \f$x\f$ having restriction \f$0\f$ while \f$y\f$ having restriction \f$1\f$ and no generator being a transfer;
in this case we cannot distinguish between \f$y\f$ and \f$x+y\f$.

* There is one final trick we can use to resolve this ambiguity as it appears the Factorization algorithm: Assume we have \f$ab\f$ living in the \f$\mathbb F_2\oplus \mathbb F_2\f$ as above and we know that \f$x\f$ (which can be distinguished from
the other two generators) is divisible by \f$b\f$. If \f$ab\f$ is \f$x\f$ there is no ambiguity, so the problem is if it's \f$y\f$ or \f$x+y\f$. 
So one of them is divisible by \f$b\f$, but since we know that \f$x\f$ is divisible by \f$b\f$, both have to be \f$b\f$ divisible and \f$a\f$ is either \f$y/b\f$ or \f$x/b+y/b\f$.  
Both of these are equally good generators of a noncyclic group, and as we are only interested in generators, we can use either of them and don't need to distinguish between them.

In practice, for \f$\mathbb Z\f$ coefficients and \f$G=C_4\f$ we can choose to ignore the products we can't identify and make no statement as to the equality of \f$ab\f$ and \f$cd\f$ if they live in non cyclic groups. This gives us less data to work with, but at least in that case this is enough to write the factorization of any element. 

For \f$G=C_4\f$ and  \f$\mathbb F_2\f$ coefficients ignoring them won't work as we have many more instances of noncyclic groups. Instead we need to use all the bulletpoints above to identify our generators and factorize every element.

\page use How to Use
\tableofcontents
\section how Step 0: Setting the Group Parameters

* For every group there are certain mandatory parameters that need to be set for the library to work. We have included an example (for \f$G=C_4\f$) on how to set them in the file  ```Implementation.h``` available in the <a href="https://github.com/NickG-Math/Mackey/tree/master/Demo">Demo</a> folder. These parameters all live in the \ref GroupSpecific "GroupSpecific" namespace and we will go over them in more detail below.

* There are also some optional parameters that allow you to identify and print the names of the computed Mackey functors. This functionality is disabled by default, but can easily be turned on by defining the macro \ref MACKEY_NAMES and setting the optional parameters living in the namespace \ref GroupSpecificOptional "GroupSpecificOptional". An example of how this is done is contained the file ```Optional_Implementation.h``` in <a href="https://github.com/NickG-Math/Mackey/tree/master/Demo">Demo</a>. The implementation there is for \f$G=C_4\f$ and the 16 Mackey functors in the \f$RO(C_4)\f$ homology. We have included both the \f$\underline{\mathbb Z}\f$ and \f$\underline{\mathbb F_2}\f$ coefficient cases for reference.

\subsection var Global variables

The global variables that need to be set are:

* \ref GroupSpecific::Variables::prime "prime" : the \f$p\f$ in \f$G=C_{p^n}\f$.
* \ref GroupSpecific::Variables::power "power" : the \f$n\f$ in \f$G=C_{p^n}\f$.
* \ref GroupSpecific::Variables::reps "reps" : the number of nontrivial irreducible real representations of \f$G\f$.
* \ref GroupSpecific::Variables::sphere_dimensions "sphere_dimensions" : the array consisting of the dimensions of those representations (so we must fix an order for them beforehand).

\subsection fun The standard differentials

* There is one function that needs to be manually defined, the \ref GroupSpecific::Function::StandardDiff "StandardDiff" computing the differentials for the standard chains. In practice this amounts to assigning the corresponding matrix given the index of the differential and the sphere (for \f$G=C_4\f$ this amounts to specifying a matrix for every triple \f$i,n,m\f$ where \f$n,m\f$ have the same signs). Apart from the case work that comes from the math, I have made the construction of these differentials as painless as possible, using the \ref Mackey::altmatrix "altmatrix" function

* \ref Mackey::altmatrix "altmatrix" returns alternating matrices of the desired size and the desired "pattern". This pattern is repeated cyclically in the columns of the matrix. An example: The matrix of size 4x4 with pattern \f$a,b\f$ is <br>
\f$\begin{matrix} a&b&a&b\\ b&a&b&a\\ a&b&a&b \\  b&a&b&a \end{matrix}\f$ <br> 
If we use the pattern \f$a,b,c,d\f$ instead we get <br>
\f$\begin{matrix} a&b&c&d\\ b&c&d&a\\ c&d&a&b \\  d&a&b&c \end{matrix}\f$ <br> 

* The matrices appearing in the Standard Chains all look like this due to equivariance

\section next Step 1: Calling the library

Once Step 0 is complete, you can include ```<Mackey/Compute.h>``` to access the methods relating to the additive and multiplicative structure and Massey products, and ```<Mackey/Factorization.h>``` to access the factorization methods. For a demonstration you can use the cpp files included in the <a href="https://github.com/NickG-Math/Mackey/tree/master/Demo">Demo</a> folder together with the provided two Implementation header files that come from Step 0.

\subsection coeff Coefficients and templates

There are two template arguments that always need to be specified, and their typenames are always ```rank_t,diff_t```. These are the coefficients used for the rank arrays and differential matrices respectively. 

* ```rank_t``` can be set to ```Eigen::Matrix<char,1,-1>``` for groups of prime power order \f$<127\f$ and we can replace ```char``` by better precision integers for higher prime power orders.

* ```diff_t``` depends on the desired coefficients: eg we can set it to ```Eigen::Matrix<char,-1,-1>``` for integer coefficients and groups of small power order, or ```Eigen<Z<N>,-1,-1>``` for \f$\mathbb Z/n\mathbb Z\f$ coefficients. The user can also define a class of coefficients and use that instead as well. An example of how this is done is 
contained in the file ```Z_n.h``` where we define \f$\mathbb Z/n\mathbb Z\f$ coefficients.


\subsection step1add The additive structure

The file ```<Mackey/Compute.h>``` exposes the method \ref Mackey::ROHomology "ROHomology" that computes the homology of a given sphere as a Mackey functor. Example: The code

<CODE> auto M= Mackey::ROHomology<rank_t,diff_t>({2,-2}); </CODE>

sets 

\f$ M=H_*(S^{2\sigma-2\lambda})\f$

Here ```M``` is an object of class \ref Mackey::MackeyFunctor "MackeyFunctor" so you should read the documentation of that on how to extract that information. If the optional parameters are set then it's also possible to extract the name of the Mackey functor using the method \ref Mackey::identify_Mackey "identify_Mackey". Simply use

<CODE> std::cout << identify_Mackey(M); </CODE>

\subsection step1mult The multiplicative structure

The file ```<Mackey/Compute.h>``` also exposes the method \ref Mackey::ROGreen "ROGreen" that multiplies two generators in the Green functor \f$H_{\star}(S)\f$. Example: The code

<CODE> auto linear_combination= Mackey::ROGreen<rank_t,diff_t>(2,{0,2,-2},{1,3,-4}); </CODE>

multiplies the generators of

\f$ H_0^{C_4}(S^{2\sigma-2\lambda}) \otimes H_1^{C_4}(S^{3\sigma-4\lambda}) \to H_1^{C_4}(S^{5\sigma-6\lambda})  \f$
\f$ a\otimes b\mapsto ab\f$

writing the answer as a linear combination of the generators in the box product. The first argument of \ref Mackey::ROGreen "ROGreen" indicates the level the generators live in (level 0=bottom, level 1= one higher etc.) so for \f$C_4\f$, level=2 is the top level. The second and third entries are the degrees of the two generators.

If the homology in these degrees is not cyclic, then the generators are not determined by their degree and need to be selected. In that case we can provide an optional final 2 ```int``` arguments in ```Mackey::ROGreen``` that perform the selection: eg \f$1,2\f$ selects the second and third generators of the noncyclic groups respectively (remember that in C++ counting starts from \f$0\f$). The default selection is \f$0,0\f$

The result of the computation ```linear_combination``` is an Eigen row vector (```rank_t```) that can be intrepreted as follows: if the result is \f$[t_1,...,t_n]\f$ then 
\f$ ab=\sum_it_ig_i\f$
where \f$g_i\f$ are the generators of the homology group the product lives in.

For convenience we normalize the basis to omit any signs and identify generators of the same cyclic groups (see \ref caveat) but it's also possible to get the nonnormalized version (\ref Mackey::Green).


\subsection step1fact Factorization

The file ```<Mackey/Factorization.h>``` exposes the class \ref Mackey::Factorization "Factorization" whose constructor creates the multiplication graph and the method \ref Mackey::Factorization::compute_with_sources "compute_with_sources" that factorizes all generators using the given sources. First construct the multiplication graph via:

<CODE>auto F= Factorization<rank_t, diff_t> F({ -5,-5 }, { 5,5 }, { {0,1,0},{2,2,0},{0,0,1},{2,0,1} }, { "asigma", "u2sigma", "alambda", "ulambda" });</CODE>

This will work in the range from \f$S^{-5\sigma-5\lambda}\f$ to \f$S^{5\sigma+5\lambda}\f$ by multiplying all generators of \f$H_{\star}S\f$ with the basic irreducibles \f$ a_{\sigma}, u_{2\sigma}, a_{\lambda}, u_{\lambda}\f$ of degrees \f$[0,1,0],[2,2,0],[0,0,1],[2,0,1]\f$ respectively.

After that, to actually get the factorizations use

<CODE>F.compute_with_sources({[0,0,0]}, {"1"});</CODE>

and 

<CODE>std::cout<< F.getname(i) </CODE>

to print the name of the ```i```-th generator. This name will be nonempty as long as the generator can be obtained by multiplying/dividing the basic irreducibles with ```1```. As such, it will fail for say ```s_3```. In that case instead use

<CODE>F.compute_with_sources({[0,0,0],[-3,0,-2]}, {"1","s3"});</CODE>

where now both \f$1\f$ and \f$s_3\f$ are used as sources.

For more details see the code in TestFactorization.cpp of the <a href="https://github.com/NickG-Math/Mackey/tree/master/Demo">Demo</a> folder


\subsection step1Mass Massey products


The file ```<Mackey/Compute.h>``` finally exposes the method \ref Mackey::ROMassey "ROMassey" for (triple) Massey products in the Green functor \f$H_{\star}(S)\f$. Example: The code


<CODE>auto Mass= Mackey::ROMassey<rank_t,diff_t>(2,{0,1,0},{-3,-3,0},{2,2,0});</CODE>

computes the Massey product \f$\langle a_{\sigma},w_3,u_{2\sigma}\rangle \f$ and its indeterminacy. As with the multiplicative structure, the Massey product is expressed in terms of a linear combination of the basis in the homology of the box product,
while the indeterminacy is expressed as two groups (left and right indeterminacy). If both are \f$0\f$ then we have the member variable ```noIndeterminacy=1```. 

We can also provide three optional ```int``` arguments at the end for selections, see \ref step1mult for what that does.

Finally, ```Mass``` is of type ```Mackey::Massey``` so read the documentation of that class to see how to extract the relevant data.

For more details see the code in TestMassey.cpp of the <a href="https://github.com/NickG-Math/Mackey/tree/master/Demo">Demo</a> folder


\page algo Algorithm Details
\tableofcontents
\section smith Smith Normal Form

For the Smith Normal Form we use a variant of the classical row-column elimination algorithm. Interestingly, for our matrices, an entry divides or is divided by any other. We optimize for this by not finding the minimum element of each submatrix, and instead work with the first nonzero element in each row and column. This is much faster for our matrices, but slower and much more dangerous for random matrices: the Smith normal form coefficient matrices \f$P,Q\f$ can easily overflow in that case (while the usual row-column elimination algorithm can give accurate results).

\section cob Change of Basis

If we have bases for modules \f$A,B\f$ then \f$A\otimes B\f$ can be canonically given two lexicographical bases, that we call left and right convenient bases. 
But if \f$A,B\f$ are the bottom levels of free Mackey functors then they have equivariant bases and the tensor product also gets an equivariant basis, called the canonical one. 
The left and right convenient bases are used to write the left and right differentials in a simple manner (hence their designation as convenient). The canonical bases are used to transfer. To get the change of basis matrix, we are reduced to computing the permutation  \f$a^{-1}b\f$ where \f$a,b\f$ are two permutations of the same set.

\section box Box product

Computing the tensor product of Chain complexes breaks down to computing the left and right differentials \f$L(x\otimes y)=dx\otimes y\f$ and \f$R(x\otimes y)=(-1)^{|x|}x\otimes dy\f$ respectively. If we use the convenient bases explained in the previous section, these are just block diagonal matrices with the blocks being the differential from the original chains \f$d\f$. To get \f$L,R\f$ w.r.t. the canonical bases, we need to apply the change of basis matrices. Once we do that the total differential of the tensor product is just \f$L+R\f$. To be more accurate, \f$L\f$ is not a single differential, but rather a sequence of them, one for each summand of the Box product; \f$(C\otimes D)_n\to (C\otimes D)_{n-1}\f$ is a map \f$C_n\otimes D_0\oplus\cdots \oplus C_0\otimes D_n\to C_0\otimes D_{n-1}\oplus\cdots\oplus C_{n-1}\otimes D_0\f$. Each summand of this map is computed separately into an \f$L\f$ and an \f$R\f$, and then these are mixed together to form the total differential. The mixing specifies that we start with a block \f$ L_0\f$, then place \f$ R_0\f$ directly below it, then \f$L_1\f$ adjecent to the right of \f$ R_0\f$ etc.

\section graph Graphs

* For weighted graphs we want the shortest path from a given source to all other points. I use a straightforward implementation of Dikjstra's algorithm using std::priority_queue.

* For graphs of two colors, we are interested in the paths from the source to all points with the minimum numer of alternating colors (an alternation of colors means switching from division to multiplication and vice-versa). 
This problem can be easily reduced to finding the shortest path for weighted graphs, by using a sort of "dual" graph where now the nodes are colored and the now monochrome edges between same colored nodes have weight 0, while for different colored nodes we get weight 1.
To get the new graph simply duplicate the nodes of the original, color the originals by red and the new ones by blue, and quadruple the edges (so we using all combinations of colored nodes) and set the weights as I just explained.
After that, find the red and blue paths starting from a red/blue source and ending to each point, compare them in length and choose the shortest one.


\page perf Performance
\tableofcontents

First, two heuristic observations:

* The Linux binary runs measurably faster than the Windows one.
* Out of all compilers, Clang seems to produce marginally faster code. 

\section compoptions Compiler Options


* I recommend the following compiler options (GCC, Clang): <CODE>-Ofast --funroll-loops -march=native </CODE>
* With the Intel compiler Eigen <a href=" http://eigen.tuxfamily.org/index.php?title=Main_Page#Compiler_support">recommends</a> the <CODE>-inline-forceinline</CODE> option.
* If OpenMP support is desired use ```-fopenmp```.
* Note: ```-Ofast``` doesn't actually reduce the accuracy of our results, since we only use integer values. This is true even when the data-type is sometimes a floating point (see \ref intvsfloat for an explanation as to why we sometimes use fp data types). 

\section thread Multithreading

* While the provided <a href="https://github.com/NickG-Math/Mackey/tree/master/bin">binaries</a> are all single-threaded, the most (by far) computationally intensive calculations can be multithreaded extemelly easily and efficiently. This is as simple as adding a ```#pragma omp parallel for``` before the loops that compute the additive/multiplicative structure in a range. There is no need to lock anything.

* There is one caveat: While the loop iterations are independent, they are not all equally computationally intensive. A sphere like \f$S^{2\sigma+\lambda}\f$ is cheaper to compute compared to \f$S^{6\sigma+8\lambda}\f$ which is in turn much cheaper compared to \f$S^{6\sigma-8\lambda}\f$ as the latter one involves a box product. In the multiplicative structure we may have to take double box products, and these are even more expensive in run-time as they involve arbitrarily large permutation matrices.

* So it's important to equally divide the work amongst the threads. Currently this has to be done manually on the user's end. Or use guided scheduling.

\section intvsfloat Integers vs Floats

I use integers (or indeed ```char``` and ```short```) for the majority of the computations; that's usually the fastest method and makes the most sense (as all numbers appearing are actually integers).
There is one important exception: Matrix multiplication. Eigen is much slower with integer matrix multiplication compared to floating points, and the Intel MKL does not even support integer matrix multiplication.
So when we need to multiply matrices we cast them to floats. This is only needed for the Homology algorithm, which is at the very end of the pipeline (together with the Smith Normal Form) so we can benefit from smaller integer types before casting.

\section memo Memoizing ChangeBasis

To form the Box product of chains we need the change of basis matrices. These matrices only depend on the ranks of the given chains. 
But the ranks that actually come up in our computations always look like [?,order,...,order,?] where order is the order of the group and ?\f$\le\f$ order. This means that we very effectively memoize this function for improved performance.

\section boxproducts Box Products 

Box products involve some very large matrices, and the more iterated box products we use the higher that complexity. 

* For the additive structure we only need to take one box product:

\f$C_*(S^V)=C_*(S^{V_{pos}})\otimes C_*(S^{-V_{neg}})=C_*(S^{V_{pos}})\otimes C^{-*}(S^{V_{neg}})\f$

where \f$V=V_{pos}-V_{neg}\f$

* For the multiplicative structure we need to take an extra box product, so up to three total when computing \f$ab\f$ for \f$a,b\f$ in the mixed homology. 

* For factorization we would also need three box products. But by design, we are only multiplying with certain basic irreducibles (Euler and orientation classes) and hope everything else is obtained like this. By selecting them to be in the pure co/homology (which the Euler and orientation classes always are) we can reduce this to two box products total.

* For Massey products we need an extra two box products, so up to five total then computing \f$\langle a,b,c\rangle \f$ for \f$a,b,c\f$ in the mixed homology. This is an extremely
large number of box products and results in matrices of millions of rows and columns, thus consuming large amounts of memory. If we combine this with OpenMP parallelization, then we can easily run out of memory using 12 threads even in a 24GB system, and get ```std::bad_alloc``` errors. It might be a good idea to use sparse matrices in this case, but that hasn't been implemented yet.

\section bottle Bottlenecks

Here are the bottlenecks in the multiplicative structure (for the additive structure only the last bottleneck appears, while Massey products dramatically increase the impact of all three).

* The biggest performance bottleneck is found in the multiplicative structure. That's when we apply some large change of basis matrices through Eigen's permutation matrix product. This is mainly a memory bottleneck.
* The second biggest bottleneck lies in the transfering very large differentials. To transfer we need to delete certain rows of the matrix, and this is done by copying the remaining rows into a new matrix.  This is another memory bottleneck.
* A third somewhat more minor bottleneck is the Smith normal form computation. The problem is that it involves going through our matrix both by rows and by columns, which is not ideal for cache locality. The SNF is both memory and core bound.
